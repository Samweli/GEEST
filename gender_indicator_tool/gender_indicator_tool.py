# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenderIndicatorTool
                                 A QGIS plugin
 Gender Indicator Tool
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-15
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Pegasys
        email                : andre@pegasys.co.za
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# QGIS and PyQt libraries and modules
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from PyQt5.QtWidgets import QFileDialog, QApplication
from qgis.core import *

# Auxiliary libraries
import os
import sys
import geopandas as gpd
import pandas as pd
import rasterio
import numpy as np
import math
import shutil
import time

# Prepare processing framework
sys.path.append(r'C:\Program Files\QGIS 3.32.0\apps\qgis\python\plugins') # Folder where Processing is located
from processing.core.Processing import Processing
Processing.initialize()
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gender_indicator_tool_dialog import GenderIndicatorToolDialog



class GenderIndicatorTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GenderIndicatorTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&World Bank Gender Indicator Tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GenderIndicatorTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gender_indicator_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&World Bank Gender Indicator Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GenderIndicatorToolDialog()

        # show the dialog
        self.dlg.show()

        ## TAB 1 - Analysis Setup ***********************************************************************
        self.dlg.workingDir_Button.clicked.connect(lambda: self.getFolder(0))



        ## TAB 2 - Individual ***************************************************************************
        ###### TAB 2.1 - Education
        self.dlg.EDU_Set_PB.clicked.connect(lambda: self.RasterizeSet(0))
        self.dlg.EDU_Execute_PB.clicked.connect(lambda: self.Rasterize(0))

        ###### TAB 2.2 - Care Responsibilities
        self.dlg.CRE_Set_PB.clicked.connect(lambda: self.RasterizeSet(1))
        self.dlg.CRE_Execute_PB.clicked.connect(lambda: self.Rasterize(1))

        ###### TAB 2.3 - Domestic Violence
        self.dlg.DOV_Set_PB.clicked.connect(lambda: self.RasterizeSet(2))
        self.dlg.DOV_Execute_PB.clicked.connect(lambda: self.Rasterize(2))

        ###### TAB 2.4 - Aggregate
        self.dlg.EDU_Aggregate_TB.clicked.connect(lambda: self.getFile(0))
        self.dlg.CRE_Aggregate_TB.clicked.connect(lambda: self.getFile(1))
        self.dlg.DOV_Aggregate_TB.clicked.connect(lambda: self.getFile(2))

        self.dlg.Indivdual_AggregateExecute_PB.clicked.connect(self.indivdualAggregation)



        ## TAB 3 - Contextual ***************************************************************************
        ###### TAB 3.1 - Policy and Legal Protection

        ###### TAB 3.2 - Access to Finance
        self.dlg.FIN_Set_PB.clicked.connect(lambda: self.RasterizeSet(3))
        self.dlg.FIN_Execute_PB.clicked.connect(lambda: self.Rasterize(3))

        ###### TAB 3.2 - Aggregate
        self.dlg.PLP_Aggregate_TB.clicked.connect(lambda: self.getFile(3))
        self.dlg.FIN_Aggregate_TB.clicked.connect(lambda: self.getFile(4))

        self.dlg.Contextual_AggregateExecute_PB.clicked.connect(self.contextualAggregation)


        ## TAB 4 - Accessibility ************************************************************************
        ###### TAB 4.1 - Women's Travel Patterns

        ###### TAB 4.2 - Public Transport
        self.dlg.PBT_Execute_PB.clicked.connect(lambda: self.ServiceArea(0))

        ###### TAB 4.3 - Ediucation & Training
        self.dlg.ETF_Execute_PB.clicked.connect(lambda: self.ServiceArea(1))

        ###### TAB 4.4 - Jobs
        self.dlg.JOB_Execute_PB.clicked.connect(lambda: self.ServiceArea(2))

        ###### TAB 4.5 - Health Facilities
        self.dlg.HEA_Execute_PB.clicked.connect(lambda: self.ServiceArea(3))

        ###### TAB 4.6 - Financial Facilities
        self.dlg.FIF_Execute_PB.clicked.connect(lambda: self.ServiceArea(4))

        ###### TAB 4.7 - Aggregate
        self.dlg.WTP_Aggregate_TB.clicked.connect(lambda: self.getFile(5))
        self.dlg.PBT_Aggregate_TB.clicked.connect(lambda: self.getFile(6))
        self.dlg.ETF_Aggregate_TB.clicked.connect(lambda: self.getFile(7))
        self.dlg.JOB_Aggregate_TB.clicked.connect(lambda: self.getFile(8))
        self.dlg.HEA_Aggregate_TB.clicked.connect(lambda: self.getFile(9))
        self.dlg.FIF_Aggregate_TB.clicked.connect(lambda: self.getFile(10))

        self.dlg.Accessibility_AggregateExecute_PB.clicked.connect(self.accessibiltyAggregation)


        ## TAB 5 - Place Charqacterization **************************************************************
        ###### TAB 5.1 - Walkability

        ###### TAB 5.2 - Cycleways

        ###### TAB 5.3 - Public Transport

        ###### TAB 5.4 - Urban Design

        ###### TAB 5.5 - Security

        ###### TAB 5.6 - Income Level
        self.dlg.INC_Set_PB.clicked.connect(lambda: self.RasterizeSet(4))
        self.dlg.INC_Execute_PB.clicked.connect(lambda: self.Rasterize(4))

        ###### TAB 5.7 - Electrical Access

        ###### TAB 5.8 - Urbanization

        ###### TAB 5.9 - Housing

        ###### TAB 5.10 - Digital Inclusion

        ###### TAB 5.11 - Natural Environment

        ###### TAB 5.12 - Aggregate
        self.dlg.WLK_Aggregate_TB.clicked.connect(lambda: self.getFile(11))
        self.dlg.CYC_Aggregate_TB.clicked.connect(lambda: self.getFile(12))
        self.dlg.APT_Aggregate_TB.clicked.connect(lambda: self.getFile(13))
        self.dlg.SAF_Aggregate_TB.clicked.connect(lambda: self.getFile(14))
        self.dlg.SEC_Aggregate_TB.clicked.connect(lambda: self.getFile(15))
        self.dlg.INC_Aggregate_TB.clicked.connect(lambda: self.getFile(16))
        self.dlg.ELC_Aggregate_TB.clicked.connect(lambda: self.getFile(17))
        self.dlg.LOU_Aggregate_TB.clicked.connect(lambda: self.getFile(18))
        self.dlg.QUH_Aggregate_TB.clicked.connect(lambda: self.getFile(19))
        self.dlg.DIG_Aggregate_TB.clicked.connect(lambda: self.getFile(20))
        self.dlg.ENV_Aggregate_TB.clicked.connect(lambda: self.getFile(21))

        self.dlg.PlaceCharacterization_AggregateExecute_PB.clicked.connect(self.placeCharacterizationAggregation)

        ## TAB 6 - Dimension Aggregation ************************************************************************
        self.dlg.ID_Aggregate_TB.clicked.connect(lambda: self.getFile(22))
        self.dlg.CD_Aggregate_TB.clicked.connect(lambda: self.getFile(23))
        self.dlg.AD_Aggregate_TB.clicked.connect(lambda: self.getFile(24))
        self.dlg.PD_Aggregate_TB.clicked.connect(lambda: self.getFile(25))

        self.dlg.Dimensions_AggregateExecute_PB.clicked.connect(self.dimesnionsAggregation)

    def getFile(self, button_num):
        response = QFileDialog.getOpenFileName(
            parent=self.dlg,
            caption='Select a file',
            directory=os.getcwd()
        )

        if button_num == 0:
            self.dlg.EDU_Aggregate_Field.setText(response[0])

        elif button_num == 1:
            self.dlg.CRE_Aggregate_Field.setText(response[0])

        elif button_num == 2:
            self.dlg.DOV_Aggregate_Field.setText(response[0])

        elif button_num == 3:
            self.dlg.PLP_Aggregate_Field.setText(response[0])

        elif button_num == 4:
            self.dlg.FIN_Aggregate_Field.setText(response[0])

        elif button_num == 5:
            self.dlg.WTP_Aggregate_Field.setText(response[0])

        elif button_num == 6:
            self.dlg.PBT_Aggregate_Field.setText(response[0])

        elif button_num == 7:
            self.dlg.ETF_Aggregate_Field.setText(response[0])

        elif button_num == 8:
            self.dlg.JOB_Aggregate_Field.setText(response[0])

        elif button_num == 9:
            self.dlg.HEA_Aggregate_Field.setText(response[0])

        elif button_num == 10:
            self.dlg.FIF_Aggregate_Field.setText(response[0])

        elif button_num == 11:
            self.dlg.WLK_Aggregate_Field.setText(response[0])

        elif button_num == 12:
            self.dlg.CYC_Aggregate_Field.setText(response[0])

        elif button_num == 13:
            self.dlg.APT_Aggregate_Field.setText(response[0])

        elif button_num == 14:
            self.dlg.SAF_Aggregate_Field.setText(response[0])

        elif button_num == 15:
            self.dlg.SEC_Aggregate_Field.setText(response[0])

        elif button_num == 16:
            self.dlg.INC_Aggregate_Field.setText(response[0])

        elif button_num == 17:
            self.dlg.ELC_Aggregate_Field.setText(response[0])

        elif button_num == 18:
            self.dlg.LOU_Aggregate_Field.setText(response[0])

        elif button_num == 19:
            self.dlg.QUH_Aggregate_Field.setText(response[0])

        elif button_num == 20:
            self.dlg.DIG_Aggregate_Field.setText(response[0])

        elif button_num == 21:
            self.dlg.ENV_Aggregate_Field.setText(response[0])

        elif button_num == 22:
            self.dlg.ID_Aggregate_Field.setText(response[0])

        elif button_num == 23:
            self.dlg.CD_Aggregate_Field.setText(response[0])

        elif button_num == 24:
            self.dlg.AD_Aggregate_Field.setText(response[0])

        elif button_num == 25:
            self.dlg.PD_Aggregate_Field.setText(response[0])

    def Check(self):
        '''
        This function will be used to check and ensure factor weightings add up to 100%
        even when there are missing factors.
        '''
        EDU_ras = self.dlg.EDU_Aggregate_Field.text().strip(" ")
        CRE_ras = self.dlg.CRE_Aggregate_Field.text().strip(" ")
        DOV_ras = self.dlg.DOV_Aggregate_Field.text().strip(" ")

        rasLayers = [EDU_ras, CRE_ras, DOV_ras]

        EDU_weight = self.dlg.EDU_Aggregate_SB.value()
        CRE_weight = self.dlg.CRE_Aggregate_SB.value()
        DOV_weight = self.dlg.DOV_Aggregate_SB.value()

        IndivdualWeighting = [EDU_weight, CRE_weight, DOV_weight]

        weightingSum = round(sum(IndivdualWeighting))

        if weightingSum == 100:
            self.dlg.Check.setText("Weighting % adds up to 100 %")
            if "" in rasLayers:
                self.dlg.Check.setText("Factor layer missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    IndivdualWeighting[i] = 0

                self.dlg.Check.setText(str(IndivdualWeighting))
            else:
                self.dlg.Check.setText("All layers present")
        else:
            self.dlg.Check.setText("Weighting % does not add up to 100 %")

    def getFolder(self, button_num):
        response = QFileDialog.getExistingDirectory(
            parent=self.dlg,
            caption='Select a folder/directory',
            directory=os.getcwd()
        )

        if button_num == 0:
            self.dlg.workingDir_Field.setText(str(response + "/"))

    def saveFile(self,button_num):
        response = QFileDialog.getSaveFileName(
            parent=self.dlg,
            caption='Save file',
            directory=os.getcwd()
        )

        if button_num == 1:
            self.dlg.IDWRasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 2:
            self.dlg.RasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 3:
            self.dlg.serviceAreaOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 4:
            self.dlg.MCAOutputFilePath_Field.setText(str(response[0]))

    def RasterizeSet(self, factor_no):
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.EDU_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.EDU_rasField_CB.addItems(fields)

        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.CRE_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.CRE_rasField_CB.addItems(fields)

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.DOV_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.DOV_rasField_CB.addItems(fields)

        elif factor_no == 3:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.FIN_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.FIN_rasField_CB.addItems(fields)

        elif factor_no == 4:
            polygonlayer = self.dlg.INC_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.INC_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.INC_rasField_CB.addItems(fields)

    def convertCRS(self, vector, UTM_crs):
        global shp_utm

        shp = gpd.read_file(vector)
        shp_wgs84 = shp.to_crs('EPSG:4326')
        shp_utm = shp_wgs84.to_crs(f'EPSG:{UTM_crs}')

# *************************** Geoprocessing Functions ********************************** #
    def Rasterize(self, factor_no):

        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        os.mkdir(tempDir)

        countryLayer = self.dlg.countryLayer_Field.filePath()

        #INPUT
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            rasField = self.dlg.EDU_rasField_CB.currentText()
            pixelSize = self.dlg.EDU_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
            
        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            rasField = self.dlg.CRE_rasField_CB.currentText()
            pixelSize = self.dlg.CRE_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            rasField = self.dlg.DOV_rasField_CB.currentText()
            pixelSize = self.dlg.DOV_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        elif factor_no == 3:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            rasField = self.dlg.FIN_rasField_CB.currentText()
            pixelSize = self.dlg.FIN_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        elif factor_no == 4:
            polygonlayer = self.dlg.INC_Input_Field.filePath()
            rasField = self.dlg.INC_rasField_CB.currentText()
            pixelSize = self.dlg.INC_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        #TEMPORARY OUTPUTS
        countryUTMLayer = f"{tempDir}/countryUTMLayer.shp"
        countryUTMLayerBuf = f"{tempDir}/countryUTMLayerBuffer.shp"
        polygonUTM = f"{tempDir}/polygonLayer_UTM.shp"
        rasterizeOutput = f"{tempDir}/polygonRas.tif"
        difference = f"{tempDir}/Difference.shp"
        mergeOutput = f"{tempDir}/Merge.shp"


        # Convert countryLayer data to UTM CRS
        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        shp_utm.to_file(countryUTMLayer)

        processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                         'DISTANCE': 2000,
                                         'SEGMENTS': 5,
                                         'END_CAP_STYLE': 0,
                                         'JOIN_STYLE': 0,
                                         'MITER_LIMIT': 2,
                                         'DISSOLVE': True,
                                         'SEPARATE_DISJOINT': False,
                                         'OUTPUT': countryUTMLayerBuf})


        # Convert spatial data to UTM CRS
        self.convertCRS(polygonlayer, UTM_crs)
        Rmax = 100
        Rmin = 0
        m_max = 5
        m_min = 0
        if factor_no == 0:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            shp_utm.to_file(polygonUTM)

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': difference,
                                                              'GRID_SIZE': None})

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': mergeOutput})

            # Get the width and height of the extent
            layer = QgsVectorLayer(mergeOutput, 'Polygon Layer', 'ogr')
            extent = layer.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Indivdual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            mergeOutput = workingDir + mergeOutput

            rasOutput = "EDU_" + self.dlg.EDU_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.EDU_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        elif factor_no == 1:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax)/(Rmin - Rmax) * m_max
            shp_utm.to_file(polygonUTM)

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': difference,
                                                              'GRID_SIZE': None})

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': mergeOutput})

            # Get the width and height of the extent
            layer = QgsVectorLayer(mergeOutput, 'Polygon Layer', 'ogr')
            extent = layer.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Indivdual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            mergeOutput = workingDir + mergeOutput
            rasOutput = "CRE_" + self.dlg.CRE_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.CRE_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        elif factor_no == 2:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax) / (Rmin - Rmax) * m_max
            shp_utm.to_file(polygonUTM)

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': difference,
                                                              'GRID_SIZE': None})

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': mergeOutput})

            # Get the width and height of the extent
            layer = QgsVectorLayer(mergeOutput, 'Polygon Layer', 'ogr')
            extent = layer.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Indivdual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            mergeOutput = workingDir + mergeOutput
            rasOutput = "DOV_" + self.dlg.DOV_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.DOV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        elif factor_no == 3:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            shp_utm.to_file(polygonUTM)

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': difference,
                                                              'GRID_SIZE': None})

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': mergeOutput})

            # Get the width and height of the extent
            layer = QgsVectorLayer(mergeOutput, 'Polygon Layer', 'ogr')
            extent = layer.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Contextual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            mergeOutput = workingDir + mergeOutput
            rasOutput = "FIN_" + self.dlg.FIN_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.FIN_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        elif factor_no == 4:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            shp_utm.to_file(polygonUTM)

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': difference,
                                                              'GRID_SIZE': None})

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': mergeOutput})

            # Get the width and height of the extent
            layer = QgsVectorLayer(mergeOutput, 'Polygon Layer', 'ogr')
            extent = layer.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            mergeOutput = workingDir + mergeOutput
            rasOutput = "INC_" + self.dlg.INC_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.INC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")



        # Loading final output to QGIS GUI viewer
        layer = QgsRasterLayer(rasOutput, f"{rasOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

    def IDW(self):

        workingDir = self.dlg.workingDir_Field.text()
        tempDir = workingDir + "temp"
        os.mkdir(tempDir)

        #INPUT
        countryAdminLayer = self.dlg.countryLayer_Field.filePath()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
        FaciltyPointlayer = self.dlg.pointLayer_Field.filePath()
        bufferDistance = self.dlg.bufferDistance_spinBox.value()
        pixelSize = self.dlg.pixelSize_spinBox.value()

        # OUTPUT
        countryAdminLayer_utm_otput = f"{tempDir}/Admin0_UTM.shp"
        FaciltyPoint_utm_output = f"{tempDir}/university_UTM.shp"
        lineToPoint_output = f"{tempDir}/lineToPoint.shp"
        mergedPoints_output = f"{tempDir}/mergedPoints.shp"
        finalOutput = self.dlg.IDWRasterOutputFilePath_Field.text()

        # Convert spatial data to UTM CRS
        self.convertCRS(countryAdminLayer, UTM_crs)
        shp_utm.to_file(countryAdminLayer_utm_otput)

        self.convertCRS(FaciltyPointlayer, UTM_crs)
        shp_utm["EScore"] = 5
        shp_utm.to_file(FaciltyPoint_utm_output)

        #Geoprocessing Algorithms
        buffer = processing.run("native:buffer", {'INPUT': FaciltyPoint_utm_output,
                                                  'DISTANCE': bufferDistance,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'OUTPUT': "memory:"})
        bufferOutput = buffer["OUTPUT"]

        polyToLine = processing.run("native:polygonstolines", {'INPUT':bufferOutput,
                                                               'OUTPUT': "memory:"})

        polyToLineOutput = polyToLine["OUTPUT"]

        lineToPoint =  processing.run("native:pointsalonglines", {'INPUT':polyToLineOutput,
                                                                  'DISTANCE':1000,
                                                                  'START_OFFSET':0,
                                                                  'END_OFFSET':0,
                                                                  'OUTPUT': lineToPoint_output})


        lineToPoint_shp = gpd.read_file(lineToPoint_output)
        lineToPoint_shp["EScore"] = 0

        merged_gdf = pd.concat([shp_utm, lineToPoint_shp], ignore_index=True)
        merged_gdf.to_file(mergedPoints_output)

        layer = QgsVectorLayer(mergedPoints_output, "mergedPoints", 'ogr')
        desired_field = 'EScore'
        field_index = layer.fields().indexFromName(desired_field)

        IDW = processing.run("qgis:idwinterpolation", {'INTERPOLATION_DATA': mergedPoints_output + f"::~::0::~::{field_index}::~::0",     #'C:/Users/Andre/Nextcloud/GIS_WBGIT/QGIS_WBGIT/test.shp::~::0::~::3::~::0'
                                                       'DISTANCE_COEFFICIENT': 2,
                                                       'EXTENT': '306969.217500000,450078.884900000,8626350.630799999,8743170.112700000 [EPSG:32738]',
                                                       'PIXEL_SIZE': pixelSize,
                                                       'OUTPUT': finalOutput})


        layer = QgsRasterLayer(finalOutput, f"{finalOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

        QMessageBox.information(self.dlg, "Message", f"IDW interpolated raster file has been created /n CRS EPSG:{UTM_crs} /threshold Distance {bufferDistance}m")

    def ServiceArea(self, factor_no):
            workingDir = self.dlg.workingDir_Field.text()
            os.chdir(workingDir)
            tempDir = "temp"

            if os.path.exists(tempDir):
                shutil.rmtree(tempDir)
            else:
                pass

            time.sleep(1)
            os.mkdir(tempDir)

            Dimension = "Accessibility"
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

            # INPUT
            if factor_no == 0:
                countryLayer = self.dlg.countryLayer_Field.filePath()
                FaciltyPointlayer = self.dlg.PBT_Input_Field.filePath()
                ranges = self.dlg.PBT_Ranges_Field.text()
                pixelSize = self.dlg.PBT_pixelSize_SB.value()
                rasOutput = "PBT_" + self.dlg.PBT_Output_Field.text()
                self.dlg.PBT_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            elif factor_no == 1:
                countryLayer = self.dlg.countryLayer_Field.filePath()
                FaciltyPointlayer = self.dlg.ETF_Input_Field.filePath()
                ranges = self.dlg.ETF_Ranges_Field.text()
                pixelSize = self.dlg.ETF_pixelSize_SB.value()
                rasOutput = "ETF_" + self.dlg.ETF_Output_Field.text()
                self.dlg.ETF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            elif factor_no == 2:
                countryLayer = self.dlg.countryLayer_Field.filePath()
                FaciltyPointlayer = self.dlg.JOB_Input_Field.filePath()
                ranges = self.dlg.JOB_Ranges_Field.text()
                pixelSize = self.dlg.JOB_pixelSize_SB.value()
                rasOutput = "JOB_" + self.dlg.JOB_Output_Field.text()
                self.dlg.JOB_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            elif factor_no == 3:
                countryLayer = self.dlg.countryLayer_Field.filePath()
                FaciltyPointlayer = self.dlg.HEA_Input_Field.filePath()
                ranges = self.dlg.HEA_Ranges_Field.text()
                pixelSize = self.dlg.HEA_pixelSize_SB.value()
                rasOutput = "HEA_" + self.dlg.HEA_Output_Field.text()
                self.dlg.HEA_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            elif factor_no == 4:
                countryLayer = self.dlg.countryLayer_Field.filePath()
                FaciltyPointlayer = self.dlg.FIF_Input_Field.filePath()
                ranges = self.dlg.FIF_Ranges_Field.text()
                pixelSize = self.dlg.FIF_pixelSize_SB.value()
                rasOutput = "FIF_" + self.dlg.FIF_Output_Field.text()
                self.dlg.FIF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")


            # TEMPORARY OUTPUT
            SAOutput = f"{tempDir}/SA_OUTPUT"
            SAOutput_utm = f"{tempDir}/SA_OUTPUT_UTM.shp"

            mergeOutput = f"{tempDir}/Merge.shp"
            mergeRasfield = f"{tempDir}/Merge_rasField.shp"
            countryUTMLayer = f"{tempDir}/countryUTMLayer.shp"
            countryUTMLayerBuf = f"{tempDir}/countryUTMLayerBuffer.shp"
            difference = f"{tempDir}/Difference.shp"
            finalMerge = f"{tempDir}/finalMerge.shp"



            gdf = gpd.read_file(FaciltyPointlayer)

            subset_size = 5
            subsets = []

            for i in range(0, len(gdf), subset_size):
                subset = gdf.iloc[i:i + subset_size]
                subset = QgsVectorLayer(subset.to_json(), "mygeojson", "ogr")
                subsets.append(f"{SAOutput}_{i}.shp")

                Service_Area = processing.run("ORS Tools:isochrones_from_layer", {'INPUT_PROVIDER': 0,
                                                                                  'INPUT_PROFILE': 6,   #Walking
                                                                                  'INPUT_POINT_LAYER': subset,
                                                                                  'INPUT_FIELD': '',
                                                                                  'INPUT_METRIC': 1,    #Distance in meters
                                                                                  'INPUT_RANGES': ranges,
                                                                                  'INPUT_AVOID_FEATURES': [],
                                                                                  'INPUT_AVOID_BORDERS': None,
                                                                                  'INPUT_AVOID_COUNTRIES': '',
                                                                                  'INPUT_AVOID_POLYGONS': None,
                                                                                  'OUTPUT': f"{SAOutput}_{i}.shp"})

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': subsets,
                                                                'CRS': None,
                                                                'OUTPUT': f"{SAOutput}.shp"})

            # Convert spatial data to UTM CRS
            self.convertCRS(f"{SAOutput}.shp", UTM_crs)
            shp_utm.to_file(SAOutput_utm)

            SA_df = gpd.read_file(SAOutput_utm)
            no_spaces_string = "".join(ranges.split())
            ranges_list = no_spaces_string.split(",")
            int_ranges_list = [int(x) for x in ranges_list]
            int_ranges_list.sort()


            for i in int_ranges_list:
                df = SA_df[SA_df['AA_METERS'] == i]
                output = f"{tempDir}/band_{i}"
                df.to_file(output + ".shp")

                dissolve = processing.run("native:dissolve", {'INPUT': output + ".shp",
                                                              'FIELD':[],
                                                              'SEPARATE_DISJOINT':False,
                                                              'OUTPUT':f"{output}_dis.shp"})
            Merge_list = []
            len_range = len(int_ranges_list)
            int_ranges_list.sort(reverse=True)
            for i in range(0, len_range-1):
                output = f"{tempDir}/band_dif_{int_ranges_list[i]}_-_{int_ranges_list[i+1]}.shp"
                Merge_list.append(output)
                processing.run("native:difference", {'INPUT': f"{tempDir}/band_{int_ranges_list[i]}_dis.shp",
                                                     'OVERLAY': f"{tempDir}/band_{int_ranges_list[i+1]}_dis.shp",
                                                     'OUTPUT': output,
                                                     'GRID_SIZE': None})

            Merge_list.append(f"{tempDir}/band_{int_ranges_list[-1]}_dis.shp")

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': Merge_list,
                                                                'CRS':None,
                                                                'OUTPUT':mergeOutput})

            merge_df = gpd.read_file(mergeOutput)
            merge_df["rasField"] = [1,2,3,4,5]
            merge_df.to_file(mergeRasfield)
            mergelayer = workingDir + mergeRasfield
            finalMerge = workingDir + finalMerge

            # Convert countryLayer data to UTM CRS
            self.convertCRS(countryLayer, UTM_crs)
            shp_utm["rasField"] = [0]
            shp_utm.to_file(countryUTMLayer)

            processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                             'DISTANCE': 2000,
                                             'SEGMENTS': 5,
                                             'END_CAP_STYLE': 0,
                                             'JOIN_STYLE': 0,
                                             'MITER_LIMIT': 2,
                                             'DISSOLVE': True,
                                             'SEPARATE_DISJOINT': False,
                                             'OUTPUT': countryUTMLayerBuf})

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY':mergelayer,
                                                              'OUTPUT':difference,
                                                              'GRID_SIZE':None})

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [mergelayer, difference],
                                                                'CRS': None,
                                                                'OUTPUT': finalMerge})

            # Get the width and height of the extent
            layer = QgsVectorLayer(finalMerge, 'Polygon Layer', 'ogr')
            extent = layer.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)


            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasterize = processing.run("gdal:rasterize", {'INPUT': finalMerge,
                                                          'FIELD': "rasField",
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})


            # Loading final output to QGIS GUI viewer
            layer = QgsRasterLayer(rasOutput, f"{rasOutput}")

            if not layer.isValid():
                print("Layer failed to load!")

            QgsProject.instance().addMapLayer(layer)

# *************************** Aggregation Functions ************************************ #
    def indivdualAggregation(self):
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        #INPUT

        EDU_ras = self.dlg.EDU_Aggregate_Field.text().strip(" ")
        CRE_ras = self.dlg.CRE_Aggregate_Field.text().strip(" ")
        DOV_ras = self.dlg.DOV_Aggregate_Field.text().strip(" ")

        EDU_weight = self.dlg.EDU_Aggregate_SB.value()
        CRE_weight = self.dlg.CRE_Aggregate_SB.value()
        DOV_weight = self.dlg.DOV_Aggregate_SB.value()

        #OUTPUT
        aggregation = self.dlg.Indivdual_AggregateOutput_Field.text()

        rasLayers = [EDU_ras, CRE_ras, DOV_ras]
        factorWeighting = [EDU_weight, CRE_weight, DOV_weight]

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.individualAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:
                with rasterio.open(rasLayers[0]) as src:
                    EDU_ras = src.read(1)
                    EDU_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CRE_ras = src.read(1)
                    CRE_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    DOV_ras = src.read(1)
                    DOV_weight = factorWeighting[2]

                # Raster Calculation

                result = ((EDU_ras * EDU_weight / 100) + (CRE_ras * CRE_weight / 100) + (DOV_ras * DOV_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Indivdual"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.ID_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Individual dimension aggregation complete!")
            else:
                self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")
        else:
            self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")

    def contextualAggregation(self):
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        PLP_ras = self.dlg.PLP_Aggregate_Field.text().strip(" ")
        FIN_ras = self.dlg.FIN_Aggregate_Field.text().strip(" ")

        PLP_weight = self.dlg.PLP_Aggregate_SB.value()
        FIN_weight = self.dlg.FIN_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.Contextual_AggregateOutput_Field.text()

        rasLayers = [PLP_ras, FIN_ras]
        factorWeighting = [PLP_weight, FIN_weight]

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.contextualAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    PLP_ras = src.read(1)
                    PLP_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    FIN_ras = src.read(1)
                    FIN_weight = factorWeighting[1]


                # Raster Calculation

                result = ((PLP_ras * PLP_weight / 100) + (FIN_ras * FIN_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Contextual"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.CD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Contextual dimension aggregation complete!")
            else:
                self.dlg.contextualAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.contextualAggregation_Check.setText("Weighting % does not add up to 100 %")

    def accessibiltyAggregation(self):
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        #INPUT
        WTP_ras = self.dlg.WTP_Aggregate_Field.text().strip(" ")
        PBT_ras = self.dlg.PBT_Aggregate_Field.text().strip(" ")
        ETF_ras = self.dlg.ETF_Aggregate_Field.text().strip(" ")
        JOB_ras = self.dlg.JOB_Aggregate_Field.text().strip(" ")
        HEA_ras = self.dlg.HEA_Aggregate_Field.text().strip(" ")
        FIF_ras = self.dlg.FIF_Aggregate_Field.text().strip(" ")

        WTP_weight = self.dlg.WTP_Aggregate_SB.value()
        PBT_weight = self.dlg.PBT_Aggregate_SB.value()
        ETF_weight = self.dlg.ETF_Aggregate_SB.value()
        JOB_weight = self.dlg.JOB_Aggregate_SB.value()
        HEA_weight = self.dlg.HEA_Aggregate_SB.value()
        FIF_weight = self.dlg.FIF_Aggregate_SB.value()

        #OUTPUT
        aggregation = self.dlg.Accessibility_AggregateOutput_Field.text()

        rasLayers = [WTP_ras, PBT_ras, ETF_ras, JOB_ras, HEA_ras, FIF_ras]
        factorWeighting = [WTP_weight, PBT_weight, ETF_weight, JOB_weight, HEA_weight, FIF_weight]

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.accessibilityAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:
                with rasterio.open(rasLayers[0]) as src:
                    WTP_ras = src.read(1)
                    WTP_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    PBT_ras = src.read(1)
                    PBT_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    ETF_ras = src.read(1)
                    ETF_weight = factorWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    JOB_ras = src.read(1)
                    JOB_weight = factorWeighting[3]

                with rasterio.open(rasLayers[4]) as src:
                    HEA_ras = src.read(1)
                    HEA_weight = factorWeighting[4]

                with rasterio.open(rasLayers[5]) as src:
                    FIF_ras = src.read(1)
                    FIF_weight = factorWeighting[5]

                # Raster Calculation

                result = ((WTP_ras * WTP_weight / 100) + (PBT_ras * PBT_weight / 100) + (ETF_ras * ETF_weight / 100)
                          + (JOB_ras * JOB_weight / 100) + (HEA_ras * HEA_weight / 100) + (FIF_ras * FIF_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Accessibility"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.AD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Accessibility dimension aggregation complete!")
            else:
                self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")
        else:
            self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")

    def placeCharacterizationAggregation(self):
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        WLK_ras = self.dlg.WLK_Aggregate_Field.text().strip(" ")
        CYC_ras = self.dlg.CYC_Aggregate_Field.text().strip(" ")
        APT_ras = self.dlg.APT_Aggregate_Field.text().strip(" ")
        SAF_ras = self.dlg.SAF_Aggregate_Field.text().strip(" ")
        SEC_ras = self.dlg.SEC_Aggregate_Field.text().strip(" ")
        INC_ras = self.dlg.INC_Aggregate_Field.text().strip(" ")
        ELC_ras = self.dlg.ELC_Aggregate_Field.text().strip(" ")
        LOU_ras = self.dlg.LOU_Aggregate_Field.text().strip(" ")
        QUH_ras = self.dlg.QUH_Aggregate_Field.text().strip(" ")
        DIG_ras = self.dlg.DIG_Aggregate_Field.text().strip(" ")
        ENV_ras = self.dlg.ENV_Aggregate_Field.text().strip(" ")

        WLK_weight = self.dlg.WLK_Aggregate_SB.value()
        CYC_weight = self.dlg.CYC_Aggregate_SB.value()
        APT_weight = self.dlg.APT_Aggregate_SB.value()
        SAF_weight = self.dlg.SAF_Aggregate_SB.value()
        SEC_weight = self.dlg.SEC_Aggregate_SB.value()
        INC_weight = self.dlg.INC_Aggregate_SB.value()
        ELC_weight = self.dlg.ELC_Aggregate_SB.value()
        LOU_weight = self.dlg.LOU_Aggregate_SB.value()
        QUH_weight = self.dlg.QUH_Aggregate_SB.value()
        DIG_weight = self.dlg.DIG_Aggregate_SB.value()
        ENV_weight = self.dlg.ENV_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.PlaceCharacterization_AggregateOutput_Field.text()

        rasLayers = [WLK_ras, CYC_ras, APT_ras, SAF_ras, SEC_ras, INC_ras, ELC_ras, LOU_ras, QUH_ras, DIG_ras, ENV_ras]
        factorWeighting = [WLK_weight, CYC_weight, APT_weight, SAF_weight, SEC_weight, INC_weight, ELC_weight, LOU_weight, QUH_weight, DIG_weight, ENV_weight]
        

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.placeCharacterizationAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    WLK_ras = src.read(1)
                    WLK_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CYC_ras = src.read(1)
                    CYC_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    APT_ras = src.read(1)
                    APT_weight = factorWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    SAF_ras = src.read(1)
                    SAF_weight = factorWeighting[3]

                with rasterio.open(rasLayers[4]) as src:
                    SEC_ras = src.read(1)
                    SEC_weight = factorWeighting[4]

                with rasterio.open(rasLayers[5]) as src:
                    INC_ras = src.read(1)
                    INC_weight = factorWeighting[5]

                with rasterio.open(rasLayers[6]) as src:
                    ELC_ras = src.read(1)
                    ELC_weight = factorWeighting[6]

                with rasterio.open(rasLayers[7]) as src:
                    LOU_ras = src.read(1)
                    LOU_weight = factorWeighting[7]

                with rasterio.open(rasLayers[8]) as src:
                    QUH_ras = src.read(1)
                    QUH_weight = factorWeighting[8]

                with rasterio.open(rasLayers[9]) as src:
                    DIG_ras = src.read(1)
                    DIG_weight = factorWeighting[9]

                with rasterio.open(rasLayers[10]) as src:
                    ENV_ras = src.read(1)
                    ENV_weight = factorWeighting[10]

                # Raster Calculation

                result = ((WLK_ras * WLK_weight / 100) + (CYC_ras * CYC_weight / 100) + (APT_ras * APT_weight / 100)
                          + (SAF_ras * SAF_weight / 100) + (SEC_ras * SEC_weight / 100) + (INC_ras * INC_weight / 100)
                          + (ELC_ras * ELC_weight / 100) + (LOU_ras * LOU_weight / 100) + (QUH_ras * QUH_weight / 100)
                          + (DIG_ras * DIG_weight / 100) + (ENV_ras * ENV_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Place Characterization"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.PD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Place Characterization dimension aggregation complete!")
            else:
                self.dlg.placeCharacterizationAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.placeCharacterizationAggregation_Check.setText("Weighting % does not add up to 100 %")

    def dimesnionsAggregation(self):
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        ID_ras = self.dlg.ID_Aggregate_Field.text().strip(" ")
        CD_ras = self.dlg.CD_Aggregate_Field.text().strip(" ")
        AD_ras = self.dlg.AD_Aggregate_Field.text().strip(" ")
        PD_ras = self.dlg.PD_Aggregate_Field.text().strip(" ")

        ID_weight = self.dlg.ID_Aggregate_SB.value()
        CD_weight = self.dlg.CD_Aggregate_SB.value()
        AD_weight = self.dlg.AD_Aggregate_SB.value()
        PD_weight = self.dlg.PD_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.Dimensions_AggregateOutput_Field.text()

        rasLayers = [ID_ras, CD_ras, AD_ras, PD_ras]
        dimensionWeighting = [ID_weight, CD_weight, AD_weight, PD_weight]

        weightingSum = round(sum(dimensionWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.dimensionAggregation_Check.setText("Dimension layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    dimensionWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(dimensionWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    ID_ras = src.read(1)
                    ID_weight = dimensionWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CD_ras = src.read(1)
                    CD_weight = dimensionWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    AD_ras = src.read(1)
                    AD_weight = dimensionWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    PD_ras = src.read(1)
                    PD_weight = dimensionWeighting[3]


                # Raster Calculation

                result = ((ID_ras * ID_weight / 100) + (CD_ras * CD_weight / 100) + (AD_ras * AD_weight / 100) + (PD_ras * PD_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Final_output = "Final_output"
                if os.path.exists(Final_output):
                    os.chdir(Final_output)
                else:
                    os.mkdir(Final_output)
                    os.chdir(Final_output)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Dimensional aggregation complete!")
            else:
                self.dlg.dimensionAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.dimensionAggregation_Check.setText("Weighting % does not add up to 100 %")
