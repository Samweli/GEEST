# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenderIndicatorTool
                                 A QGIS plugin
 Gender Indicator Tool
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-15
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Pegasys
        email                : andre@pegasys.co.za
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# QGIS and PyQt libraries and modules
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from PyQt5.QtWidgets import QFileDialog, QApplication
from qgis.core import *

# Auxiliary libraries
import os
import sys
import geopandas as gpd
import pandas as pd
import rasterio
import numpy as np
import math
import shutil
import time

# Prepare processing framework
sys.path.append(r'C:\Program Files\QGIS 3.32.0\apps\qgis\python\plugins') # Folder where Processing is located
from processing.core.Processing import Processing
Processing.initialize()
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gender_indicator_tool_dialog import GenderIndicatorToolDialog



class GenderIndicatorTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GenderIndicatorTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&World Bank Gender Indicator Tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GenderIndicatorTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gender_indicator_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&World Bank Gender Indicator Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GenderIndicatorToolDialog()

        # show the dialog
        self.dlg.show()

        ## TAB 1 - Analysis Setup ***********************************************************************
        self.dlg.workingDir_Button.clicked.connect(lambda: self.getFolder(0))



        ## TAB 2 - Individual ***************************************************************************
        ###### TAB 2.1 - Education
        self.dlg.EDU_Set_PB.clicked.connect(lambda: self.RasterizeSet(0))
        self.dlg.EDU_Execute_PB.clicked.connect(lambda: self.Rasterize(0))

        ###### TAB 2.2 - Care Responsibilities
        self.dlg.CRE_Set_PB.clicked.connect(lambda: self.RasterizeSet(1))
        self.dlg.CRE_Execute_PB.clicked.connect(lambda: self.Rasterize(1))

        ###### TAB 2.3 - Domestic Violence
        self.dlg.DOV_Set_PB.clicked.connect(lambda: self.RasterizeSet(2))
        self.dlg.DOV_Execute_PB.clicked.connect(lambda: self.Rasterize(2))

        ###### TAB 2.4 - Aggregate
        self.dlg.EDU_Aggregate_TB.clicked.connect(lambda: self.getFile(0))
        self.dlg.CRE_Aggregate_TB.clicked.connect(lambda: self.getFile(1))
        self.dlg.DOV_Aggregate_TB.clicked.connect(lambda: self.getFile(2))

        self.dlg.Indivdual_AggregateExecute_PB.clicked.connect(self.indivdualAggregation)



        ## TAB 3 - Contextual ***************************************************************************
        ###### TAB 3.1 - Policy and Legal Protection

        ###### TAB 3.2 - Access to Finance
        self.dlg.FIN_Set_PB.clicked.connect(lambda: self.RasterizeSet(3))
        self.dlg.FIN_Execute_PB.clicked.connect(lambda: self.Rasterize(3))

        ###### TAB 3.2 - Aggregate
        self.dlg.PLP_Aggregate_TB.clicked.connect(lambda: self.getFile(3))
        self.dlg.FIN_Aggregate_TB.clicked.connect(lambda: self.getFile(4))

        self.dlg.Contextual_AggregateExecute_PB.clicked.connect(self.contextualAggregation)


        ## TAB 4 - Accessibility ************************************************************************
        ###### TAB 4.1 - Women's Travel Patterns --------------------------------------------------------

        ###### TAB 4.2 - Public Transport ---------------------------------------------------------------
        self.dlg.PBT_Execute_PB.clicked.connect(lambda: self.ServiceArea(0))

        ###### TAB 4.3 - Ediucation & Training ----------------------------------------------------------
        self.dlg.ETF_Execute_PB.clicked.connect(lambda: self.ServiceArea(1))

        ###### TAB 4.4 - Jobs ---------------------------------------------------------------------------
        self.dlg.JOB_Execute_PB.clicked.connect(lambda: self.ServiceArea(2))

        ###### TAB 4.5 - Health Facilities --------------------------------------------------------------
        self.dlg.HEA_Execute_PB.clicked.connect(lambda: self.ServiceArea(3))

        ###### TAB 4.6 - Financial Facilities -----------------------------------------------------------
        self.dlg.FIF_Execute_PB.clicked.connect(lambda: self.ServiceArea(4))

        ## TAB 5 - Place Charqacterization **************************************************************

        ## TAB 6 - Dimension MCE ************************************************************************
        self.dlg.MCAOutputFilePath_Button.clicked.connect(lambda: self.saveFile(4))
        # self.dlg.pbMCAExecute.clicked.connect(self.MCA)

    def getFile(self, button_num):
        response = QFileDialog.getOpenFileName(
            parent=self.dlg,
            caption='Select a file',
            directory=os.getcwd()
        )

        if button_num == 0:
            self.dlg.EDU_Aggregate_Field.setText(response[0])

        elif button_num == 1:
            self.dlg.CRE_Aggregate_Field.setText(response[0])

        elif button_num == 2:
            self.dlg.DOV_Aggregate_Field.setText(response[0])

        elif button_num == 3:
            self.dlg.PLP_Aggregate_Field.setText(response[0])

        elif button_num == 4:
            self.dlg.FIN_Aggregate_Field.setText(response[0])

    def Check(self):
        '''
        This function will be used to check and ensure factor weightings add up to 100%
        even when there are missing factors.
        '''
        EDU_ras = self.dlg.EDU_Aggregate_Field.text().strip(" ")
        CRE_ras = self.dlg.CRE_Aggregate_Field.text().strip(" ")
        DOV_ras = self.dlg.DOV_Aggregate_Field.text().strip(" ")

        rasLayers = [EDU_ras, CRE_ras, DOV_ras]

        EDU_weight = self.dlg.EDU_Aggregate_SB.value()
        CRE_weight = self.dlg.CRE_Aggregate_SB.value()
        DOV_weight = self.dlg.DOV_Aggregate_SB.value()

        IndivdualWeighting = [EDU_weight, CRE_weight, DOV_weight]

        weightingSum = round(sum(IndivdualWeighting))

        if weightingSum == 100:
            self.dlg.Check.setText("Weighting % adds up to 100 %")
            if "" in rasLayers:
                self.dlg.Check.setText("Factor layer missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    IndivdualWeighting[i] = 0

                self.dlg.Check.setText(str(IndivdualWeighting))
            else:
                self.dlg.Check.setText("All layers present")
        else:
            self.dlg.Check.setText("Weighting % does not add up to 100 %")

    def getFolder(self, button_num):
        response = QFileDialog.getExistingDirectory(
            parent=self.dlg,
            caption='Select a folder/directory',
            directory=os.getcwd()
        )

        if button_num == 0:
            self.dlg.workingDir_Field.setText(str(response + "/"))

    def saveFile(self,button_num):
        response = QFileDialog.getSaveFileName(
            parent=self.dlg,
            caption='Save file',
            directory=os.getcwd()
        )

        if button_num == 1:
            self.dlg.IDWRasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 2:
            self.dlg.RasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 3:
            self.dlg.serviceAreaOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 4:
            self.dlg.MCAOutputFilePath_Field.setText(str(response[0]))

    def RasterizeSet(self, factor_no):
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.EDU_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.EDU_rasField_CB.addItems(fields)

        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.CRE_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.CRE_rasField_CB.addItems(fields)

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.DOV_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.DOV_rasField_CB.addItems(fields)

        elif factor_no == 3:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.FIN_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.FIN_rasField_CB.addItems(fields)

    def convertCRS(self, vector, UTM_crs):
        global shp_utm

        shp = gpd.read_file(vector)
        shp_wgs84 = shp.to_crs('EPSG:4326')
        shp_utm = shp_wgs84.to_crs(f'EPSG:{UTM_crs}')

# *************************** Geoprocessing Functions ********************************** #
    def Rasterize(self, factor_no):

        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        os.mkdir(tempDir)

        #INPUT
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            rasField = self.dlg.EDU_rasField_CB.currentText()
            pixelSize = self.dlg.EDU_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
            
        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            rasField = self.dlg.CRE_rasField_CB.currentText()
            pixelSize = self.dlg.CRE_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            rasField = self.dlg.DOV_rasField_CB.currentText()
            pixelSize = self.dlg.DOV_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        elif factor_no == 3:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            rasField = self.dlg.FIN_rasField_CB.currentText()
            pixelSize = self.dlg.FIN_pixelSize_SB.value()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        #TEMPORARY OUTPUTS
        polygonUTM = f"{tempDir}/polygonLayer_UTM.shp"
        rasterizeOutput = f"{tempDir}/polygonRas.tif"


        # Convert spatial data to UTM CRS
        self.convertCRS(polygonlayer, UTM_crs)
        shp_utm.to_file(polygonUTM)

        # Get the width and height of the extent
        layer = QgsVectorLayer(polygonUTM, 'Polygon Layer', 'ogr')
        extent = layer.extent()
        raster_width = int(extent.width() / pixelSize) + 1
        raster_height = int(extent.height() / pixelSize) + 1

        rasterize = processing.run("gdal:rasterize", {'INPUT': polygonlayer,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': 0,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasterizeOutput})


        rasterizeOutput = rasterize["OUTPUT"]
        # *************************** Standardization **********************************
        with rasterio.open(rasterizeOutput) as src:
            Ri = src.read(1)
            Ri[Ri == 0] = np.nan
            meta = src.meta
            Rmax = 100
            Rmin = 0
            m_max = 5
            m_min = 0

            #Xi = m_max - ((Ri - Rmin) / (Rmax - Rmin)) * (m_max - m_min) #Inverser Linear scaling formula???

        # Raster Calculation
        if factor_no == 0:
            result = (Ri - Rmin)/(Rmax - Rmin) * m_max

            meta.update(dtype=rasterio.float32)

            Dimension  = "Indivdual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = "EDU_" + self.dlg.EDU_Output_Field.text()

            with rasterio.open(rasOutput, 'w', **meta) as dst:
                dst.write(result, 1)

            self.dlg.EDU_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        elif factor_no == 1:
            result = (Ri - Rmax)/(Rmin - Rmax) * m_max
                # m_max - ((Ri - Rmin) / (Rmax - Rmin)) * (m_max - m_min)

            Dimension = "Indivdual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = "CRE_" + self.dlg.CRE_Output_Field.text()

            with rasterio.open(rasOutput, 'w', **meta) as dst:
                dst.write(result, 1)

            self.dlg.CRE_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        elif factor_no == 2:
            result = (Ri - Rmax)/(Rmin - Rmax) * m_max
                # m_max - ((Ri - Rmin) / (Rmax - Rmin)) * (m_max - m_min)

            Dimension = "Indivdual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = "DOV_" + self.dlg.DOV_Output_Field.text()

            with rasterio.open(rasOutput, 'w', **meta) as dst:
                dst.write(result, 1)

            self.dlg.DOV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        if factor_no == 3:
            result = (Ri - Rmin)/(Rmax - Rmin) * m_max

            meta.update(dtype=rasterio.float32)

            Dimension  = "Contextual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = "FIN_" + self.dlg.FIN_Output_Field.text()

            with rasterio.open(rasOutput, 'w', **meta) as dst:
                dst.write(result, 1)

            self.dlg.FIN_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")


        # Loading final output to QGIS GUI viewer
        layer = QgsRasterLayer(rasOutput, f"{rasOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

    def IDW(self):

        workingDir = self.dlg.workingDir_Field.text()
        tempDir = workingDir + "temp"
        os.mkdir(tempDir)

        #INPUT
        countryAdminLayer = self.dlg.countryLayer_Field.filePath()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
        FaciltyPointlayer = self.dlg.pointLayer_Field.filePath()
        bufferDistance = self.dlg.bufferDistance_spinBox.value()
        pixelSize = self.dlg.pixelSize_spinBox.value()

        # OUTPUT
        countryAdminLayer_utm_otput = f"{tempDir}/Admin0_UTM.shp"
        FaciltyPoint_utm_output = f"{tempDir}/university_UTM.shp"
        lineToPoint_output = f"{tempDir}/lineToPoint.shp"
        mergedPoints_output = f"{tempDir}/mergedPoints.shp"
        finalOutput = self.dlg.IDWRasterOutputFilePath_Field.text()

        # Convert spatial data to UTM CRS
        self.convertCRS(countryAdminLayer, UTM_crs)
        shp_utm.to_file(countryAdminLayer_utm_otput)

        self.convertCRS(FaciltyPointlayer, UTM_crs)
        shp_utm["EScore"] = 5
        shp_utm.to_file(FaciltyPoint_utm_output)

        #Geoprocessing Algorithms
        buffer = processing.run("native:buffer", {'INPUT': FaciltyPoint_utm_output,
                                                  'DISTANCE': bufferDistance,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'OUTPUT': "memory:"})
        bufferOutput = buffer["OUTPUT"]

        polyToLine = processing.run("native:polygonstolines", {'INPUT':bufferOutput,
                                                               'OUTPUT': "memory:"})

        polyToLineOutput = polyToLine["OUTPUT"]

        lineToPoint =  processing.run("native:pointsalonglines", {'INPUT':polyToLineOutput,
                                                                  'DISTANCE':1000,
                                                                  'START_OFFSET':0,
                                                                  'END_OFFSET':0,
                                                                  'OUTPUT': lineToPoint_output})


        lineToPoint_shp = gpd.read_file(lineToPoint_output)
        lineToPoint_shp["EScore"] = 0

        merged_gdf = pd.concat([shp_utm, lineToPoint_shp], ignore_index=True)
        merged_gdf.to_file(mergedPoints_output)

        layer = QgsVectorLayer(mergedPoints_output, "mergedPoints", 'ogr')
        desired_field = 'EScore'
        field_index = layer.fields().indexFromName(desired_field)

        IDW = processing.run("qgis:idwinterpolation", {'INTERPOLATION_DATA': mergedPoints_output + f"::~::0::~::{field_index}::~::0",     #'C:/Users/Andre/Nextcloud/GIS_WBGIT/QGIS_WBGIT/test.shp::~::0::~::3::~::0'
                                                       'DISTANCE_COEFFICIENT': 2,
                                                       'EXTENT': '306969.217500000,450078.884900000,8626350.630799999,8743170.112700000 [EPSG:32738]',
                                                       'PIXEL_SIZE': pixelSize,
                                                       'OUTPUT': finalOutput})


        layer = QgsRasterLayer(finalOutput, f"{finalOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

        QMessageBox.information(self.dlg, "Message", f"IDW interpolated raster file has been created /n CRS EPSG:{UTM_crs} /threshold Distance {bufferDistance}m")

    def ServiceArea(self, factor_no):

        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        os.mkdir(tempDir)

        # INPUT
        if factor_no == 0:
            FaciltyPointlayer = self.dlg.PBT_Input_Field.filePath()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
            ranges = self.dlg.PBT_Ranges_Field.text()
            pixelSize = self.dlg.PBT_pixelSize_SB.value()
            rasOutput = "PBT_" + self.dlg.PBT_Output_Field.text()

        elif factor_no == 1:
            FaciltyPointlayer = self.dlg.ETF_Input_Field.filePath()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
            ranges = self.dlg.ETF_Ranges_Field.text()
            pixelSize = self.dlg.ETF_pixelSize_SB.value()
            rasOutput = "ETF_" + self.dlg.ETF_Output_Field.text()

        elif factor_no == 2:
            FaciltyPointlayer = self.dlg.JOB_Input_Field.filePath()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
            ranges = self.dlg.JOB_Ranges_Field.text()
            pixelSize = self.dlg.JOB_pixelSize_SB.value()
            rasOutput = "JOB_" + self.dlg.JOB_Output_Field.text()

        elif factor_no == 3:
            FaciltyPointlayer = self.dlg.HEA_Input_Field.filePath()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
            ranges = self.dlg.HEA_Ranges_Field.text()
            pixelSize = self.dlg.HEA_pixelSize_SB.value()
            rasOutput = "HEA_" + self.dlg.HEA_Output_Field.text()

        elif factor_no == 4:
            FaciltyPointlayer = self.dlg.FIF_Input_Field.filePath()
            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
            ranges = self.dlg.FIF_Ranges_Field.text()
            pixelSize = self.dlg.FIF_pixelSize_SB.value()
            rasOutput = "FIF_" + self.dlg.FIF_Output_Field.text()


        # TEMPORARY OUTPUT
        SAOutput_utm_otput = f"{tempDir}/FaciltyPointlayer_UTM.shp"
        SAOutput = f"{tempDir}/SA_OUTPUT.shp"
        mergeOutput = f"{tempDir}/Merge.shp"
        mergeRasfield = f"{tempDir}/Merge_rasField.shp"
        polygonUTM = f"{tempDir}/polygonLayer_UTM.shp"
        rasterizeOutput = f"{tempDir}/polygonRas.tif"

        # finalOutput = self.dlg.serviceAreaOutputFilePath_Field.text()


        
        Service_Area = processing.run("ORS Tools:isochrones_from_layer", {'INPUT_PROVIDER': 0,
                                                                          'INPUT_PROFILE': 6,   #Walking
                                                                          'INPUT_POINT_LAYER': FaciltyPointlayer,
                                                                          'INPUT_FIELD': '',
                                                                          'INPUT_METRIC': 1,    #Distance in meters
                                                                          'INPUT_RANGES': ranges,
                                                                          'INPUT_AVOID_FEATURES': [],
                                                                          'INPUT_AVOID_BORDERS': None,
                                                                          'INPUT_AVOID_COUNTRIES': '',
                                                                          'INPUT_AVOID_POLYGONS': None,
                                                                          'OUTPUT': SAOutput})

        # Convert spatial data to UTM CRS
        self.convertCRS(SAOutput, UTM_crs)
        shp_utm.to_file(SAOutput_utm_otput)

        SA_df = gpd.read_file(SAOutput_utm_otput)
        no_spaces_string = "".join(ranges.split())
        ranges_list = no_spaces_string.split(",")
        int_ranges_list = [int(x) for x in ranges_list]
        int_ranges_list.sort()

        # QMessageBox.information(self.dlg, "Message", f"{ranges_list}")
        for i in int_ranges_list:
            df = SA_df[SA_df['AA_METERS'] == i]
            output = f"{tempDir}/band_{i}"
            df.to_file(output + ".shp")

            dissolve = processing.run("native:dissolve", {'INPUT': output + ".shp",
                                                          'FIELD':[],
                                                          'SEPARATE_DISJOINT':False,
                                                          'OUTPUT':f"{output}_dis.shp"})
        Merge_list = []
        len_range = len(int_ranges_list)
        int_ranges_list.sort(reverse=True)
        for i in range(0, len_range-1):
            output = f"{tempDir}/band_dif_{int_ranges_list[i]}_-_{int_ranges_list[i+1]}.shp"
            Merge_list.append(output)
            processing.run("native:difference", {'INPUT': f"{tempDir}/band_{int_ranges_list[i]}_dis.shp",
                                                 'OVERLAY': f"{tempDir}/band_{int_ranges_list[i+1]}_dis.shp",
                                                 'OUTPUT': output,
                                                 'GRID_SIZE': None})

        Merge_list.append(f"{tempDir}/band_{int_ranges_list[-1]}_dis.shp")

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': Merge_list,
                                                            'CRS':None,
                                                            'OUTPUT':mergeOutput})

        merge_df = gpd.read_file(mergeOutput)
        merge_df["rasField"] = [1,2,3,4,5]
        merge_df.to_file(mergeRasfield)
        polygonlayer = workingDir + mergeRasfield

        # Convert spatial data to UTM CRS
        self.convertCRS(polygonlayer, UTM_crs)
        shp_utm.to_file(polygonUTM)

        # Get the width and height of the extent
        layer = QgsVectorLayer(polygonUTM, 'Polygon Layer', 'ogr')
        extent = layer.extent()
        raster_width = int(extent.width() / pixelSize) + 1
        raster_height = int(extent.height() / pixelSize) + 1


        Dimension = "Accessibility"
        if os.path.exists(Dimension):
            os.chdir(Dimension)
        else:
            os.mkdir(Dimension)
            os.chdir(Dimension)

        rasterize = processing.run("gdal:rasterize", {'INPUT': polygonlayer,
                                                      'FIELD': "rasField",
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': 0,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        # Loading final output to QGIS GUI viewer
        layer = QgsRasterLayer(rasOutput, f"{rasOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)
        
        # Loading final output to QGIS GUI viewer
        # layer = QgsVectorLayer(finalOutput, f"{finalOutput}")
        #
        # if not layer.isValid():
        #     print("Layer failed to load!")
        #
        # QgsProject.instance().addMapLayer(layer)

# *************************** Aggregation Functions ************************************ #
    def indivdualAggregation(self):
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        #INPUT
        EDU_ras = self.dlg.EDU_Aggregate_Field.text().strip(" ")
        CRE_ras = self.dlg.CRE_Aggregate_Field.text().strip(" ")
        DOV_ras = self.dlg.DOV_Aggregate_Field.text().strip(" ")

        EDU_weight = self.dlg.EDU_Aggregate_SB.value()
        CRE_weight = self.dlg.CRE_Aggregate_SB.value()
        DOV_weight = self.dlg.DOV_Aggregate_SB.value()

        #OUTPUT
        aggregation = self.dlg.Indivdual_AggregateOutput_Field.text()

        rasLayers = [EDU_ras, CRE_ras, DOV_ras]
        IndivdualWeighting = [EDU_weight, CRE_weight, DOV_weight]

        weightingSum = round(sum(IndivdualWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.individualAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    IndivdualWeighting[i] = 0

            else:
                self.dlg.individualAggregation_Check.setText("All layers present")

            with rasterio.open(rasLayers[0]) as src:
                EDU_ras = src.read(1)
                EDU_weight = IndivdualWeighting[0]
                meta1 = src.meta

            with rasterio.open(rasLayers[1]) as src:
                CRE_ras = src.read(1)
                CRE_weight = IndivdualWeighting[1]

            with rasterio.open(rasLayers[2]) as src:
                DOV_ras = src.read(1)
                DOV_weight = IndivdualWeighting[2]

            # Raster Calculation

            result = ((EDU_ras * EDU_weight / 100) + (CRE_ras * CRE_weight / 100) + (DOV_ras * DOV_weight / 100))

            meta1.update(dtype=rasterio.float32)

            Dimension = "Indivdual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            with rasterio.open(aggregation, 'w', **meta1) as dst:
                dst.write(result, 1)

            layer = QgsRasterLayer(aggregation, f"{aggregation}")

            if not layer.isValid():
                print("Layer failed to load!")

            QgsProject.instance().addMapLayer(layer)

            QMessageBox.information(self.dlg, "Message", f"Individual dimension aggregation complete!")
            
        else:
            self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")

    def contextualAggregation(self):
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        PLP_ras = self.dlg.PLP_Aggregate_Field.text().strip(" ")
        FIN_ras = self.dlg.FIN_Aggregate_Field.text().strip(" ")

        PLP_weight = self.dlg.PLP_Aggregate_SB.value()
        FIN_weight = self.dlg.FIN_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.Contextual_AggregateOutput_Field.text()

        rasLayers = [PLP_ras, FIN_ras]
        IndivdualWeighting = [PLP_weight, FIN_weight]

        weightingSum = round(sum(IndivdualWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.contextualAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    IndivdualWeighting[i] = 0

            else:
                self.dlg.contextualAggregation_Check.setText("All layers present")

            with rasterio.open(rasLayers[0]) as src:
                PLP_ras = src.read(1)
                PLP_weight = IndivdualWeighting[0]
                meta1 = src.meta

            with rasterio.open(rasLayers[1]) as src:
                FIN_ras = src.read(1)
                FIN_weight = IndivdualWeighting[1]


            # Raster Calculation

            result = ((PLP_ras * PLP_weight / 100) + (FIN_ras * FIN_weight / 100))

            meta1.update(dtype=rasterio.float32)

            Dimension = "Contextual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            with rasterio.open(aggregation, 'w', **meta1) as dst:
                dst.write(result, 1)

            layer = QgsRasterLayer(aggregation, f"{aggregation}")

            if not layer.isValid():
                print("Layer failed to load!")

            QgsProject.instance().addMapLayer(layer)

            QMessageBox.information(self.dlg, "Message", f"Contextual dimension aggregation complete!")

        else:
            self.dlg.contextualAggregation_Check.setText("Weighting % does not add up to 100 %")

