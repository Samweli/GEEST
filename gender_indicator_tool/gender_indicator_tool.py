# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenderIndicatorTool
                                 A QGIS plugin
 Gender Indicator Tool
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-15
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Pegasys
        email                : andre@pegasys.co.za
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# QGIS and PyQt libraries and modules
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from PyQt5.QtWidgets import QFileDialog, QApplication
from qgis.core import *

# Auxiliary libraries
import os
import sys
import geopandas as gpd
import pandas as pd
import rasterio
import numpy as np
import math
import shutil
import time
import logging
import ast

# Prepare processing framework
sys.path.append(r'C:\Program Files\QGIS 3.32.0\apps\qgis\python\plugins') # Folder where Processing is located
from processing.core.Processing import Processing
Processing.initialize()
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gender_indicator_tool_dialog import GenderIndicatorToolDialog



class GenderIndicatorTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GenderIndicatorTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&World Bank Gender Indicator Tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GenderIndicatorTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gender_indicator_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&World Bank Gender Indicator Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GenderIndicatorToolDialog()

        # show the dialog
        self.dlg.show()


        ## TAB 1 - Analysis Setup ***********************************************************************
        self.dlg.workingDir_Button.clicked.connect(lambda: self.getFolder(0))



        ## TAB 2 - Individual ***************************************************************************
        ###### TAB 2.1 - Education
        self.dlg.EDU_Set_PB.clicked.connect(lambda: self.RasterizeSet(0))
        self.dlg.EDU_Execute_PB.clicked.connect(lambda: self.Rasterize(0))

        ###### TAB 2.2 - Care Responsibilities
        self.dlg.CRE_Set_PB.clicked.connect(lambda: self.RasterizeSet(1))
        self.dlg.CRE_Execute_PB.clicked.connect(lambda: self.Rasterize(1))

        ###### TAB 2.3 - Domestic Violence
        self.dlg.DOV_Set_PB.clicked.connect(lambda: self.RasterizeSet(2))
        self.dlg.DOV_Execute_PB.clicked.connect(lambda: self.Rasterize(2))

        ###### TAB 2.4 - Aggregate
        self.dlg.EDU_Aggregate_TB.clicked.connect(lambda: self.getFile(0))
        self.dlg.CRE_Aggregate_TB.clicked.connect(lambda: self.getFile(1))
        self.dlg.DOV_Aggregate_TB.clicked.connect(lambda: self.getFile(2))

        self.dlg.Indivdual_AggregateExecute_PB.clicked.connect(self.indivdualAggregation)

        ## TAB 3 - Contextual ***************************************************************************
        ###### TAB 3.1 - Policy and Legal Protection
        self.dlg.PLP_Set_PB.clicked.connect(lambda: self.RasterizeSet(3))
        self.dlg.PLP_Execute_PB.clicked.connect(lambda: self.Rasterize(3))

        ###### TAB 3.2 - Access to Finance
        self.dlg.FIN_Set_PB.clicked.connect(lambda: self.RasterizeSet(4))
        self.dlg.FIN_Execute_PB.clicked.connect(lambda: self.Rasterize(4))

        ###### TAB 3.2 - Aggregate
        self.dlg.PLP_Aggregate_TB.clicked.connect(lambda: self.getFile(3))
        self.dlg.FIN_Aggregate_TB.clicked.connect(lambda: self.getFile(4))

        self.dlg.Contextual_AggregateExecute_PB.clicked.connect(self.contextualAggregation)


        ## TAB 4 - Accessibility ************************************************************************
        Modes = ['Walking', 'Driving']
        Measurement = ['Distance', 'Time']
        ###### TAB 4.1 - Women's Travel Patterns
        self.dlg.WTP_mode_CB.clear()
        self.dlg.WTP_mode_CB.addItems(Modes)
        self.dlg.WTP_measurement_CB.clear()
        self.dlg.WTP_measurement_CB.addItems(Measurement)
        self.dlg.WTP_Execute_PB.clicked.connect(lambda: self.ServiceArea(5))

        self.dlg.WTP_Aggregate_PB.clicked.connect(self.wtpAggregate)

        ###### TAB 4.2 - Public Transport
        self.dlg.PBT_mode_CB.clear()
        self.dlg.PBT_mode_CB.addItems(Modes)
        self.dlg.PBT_measurement_CB.clear()
        self.dlg.PBT_measurement_CB.addItems(Measurement)
        self.dlg.PBT_Execute_PB.clicked.connect(lambda: self.ServiceArea(0))

        ###### TAB 4.3 - Ediucation & Training
        self.dlg.ETF_mode_CB.clear()
        self.dlg.ETF_mode_CB.addItems(Modes)
        self.dlg.ETF_measurement_CB.clear()
        self.dlg.ETF_measurement_CB.addItems(Measurement)
        self.dlg.ETF_Execute_PB.clicked.connect(lambda: self.ServiceArea(1))

        ###### TAB 4.4 - Jobs
        self.dlg.JOB_mode_CB.clear()
        self.dlg.JOB_mode_CB.addItems(Modes)
        self.dlg.JOB_measurement_CB.clear()
        self.dlg.JOB_measurement_CB.addItems(Measurement)
        self.dlg.JOB_Execute_PB.clicked.connect(lambda: self.ServiceArea(2))

        ###### TAB 4.5 - Health Facilities
        self.dlg.HEA_mode_CB.clear()
        self.dlg.HEA_mode_CB.addItems(Modes)
        self.dlg.HEA_measurement_CB.clear()
        self.dlg.HEA_measurement_CB.addItems(Measurement)
        self.dlg.HEA_Execute_PB.clicked.connect(lambda: self.ServiceArea(3))

        ###### TAB 4.6 - Financial Facilities
        self.dlg.FIF_mode_CB.clear()
        self.dlg.FIF_mode_CB.addItems(Modes)
        self.dlg.FIF_measurement_CB.clear()
        self.dlg.FIF_measurement_CB.addItems(Measurement)
        self.dlg.FIF_Execute_PB.clicked.connect(lambda: self.ServiceArea(4))

        ###### TAB 4.7 - Aggregate
        self.dlg.WTP_Aggregate_TB.clicked.connect(lambda: self.getFile(5))
        self.dlg.PBT_Aggregate_TB.clicked.connect(lambda: self.getFile(6))
        self.dlg.ETF_Aggregate_TB.clicked.connect(lambda: self.getFile(7))
        self.dlg.JOB_Aggregate_TB.clicked.connect(lambda: self.getFile(8))
        self.dlg.HEA_Aggregate_TB.clicked.connect(lambda: self.getFile(9))
        self.dlg.FIF_Aggregate_TB.clicked.connect(lambda: self.getFile(10))

        self.dlg.Accessibility_AggregateExecute_PB.clicked.connect(self.accessibiltyAggregation)


        ## TAB 5 - Place Charqacterization **************************************************************
        ###### TAB 5.1 - Walkability
        self.dlg.WLK_Set_PB.clicked.connect(lambda: self.TypeSet(1))
        self.dlg.WLK_unique_PB.clicked.connect(lambda: self.uniqueValues(1))
        self.dlg.WLK_Execute_PB.clicked.connect(self.walkability)

        ###### TAB 5.2 - Cycleways
        self.dlg.CYC_Set_PB.clicked.connect(lambda: self.TypeSet(2))
        self.dlg.CYC_unique_PB.clicked.connect(lambda: self.uniqueValues(2))
        self.dlg.CYC_Execute_PB.clicked.connect(self.cycleways)

        ###### TAB 5.3 - Public Transport
        self.dlg.SAF_Execute_PB.clicked.connect(self.nightTimeLights)

        ###### TAB 5.4 - Safe Urban Design
        self.dlg.APT_Execute_PB.clicked.connect(self.transportCount)

        ###### TAB 5.5 - Security
        self.dlg.SEC_Set_PB.clicked.connect(lambda: self.RasterizeSet(6))
        self.dlg.SEC_Execute_PB.clicked.connect(lambda: self.Rasterize(6))

        self.dlg.SEC_Aggregate_PB.clicked.connect(self.secAggregate)

        ###### TAB 5.6 - Income Level
        self.dlg.INC_Set_PB.clicked.connect(lambda: self.RasterizeSet(5))
        self.dlg.INC_Execute_PB.clicked.connect(lambda: self.Rasterize(5))

        ###### TAB 5.7 - Electrical Access
        self.dlg.ELC_Set_PB.clicked.connect(lambda: self.RasterizeSet(7))
        self.dlg.ELC_Execute_PB.clicked.connect(lambda: self.Rasterize(7))

        ###### TAB 5.8 - Urbanization

        ###### TAB 5.9 - Housing
        self.dlg.QUH_Execute_PB.clicked.connect(self.housing)

        ###### TAB 5.10 - Digital Inclusion
        self.dlg.DIG_Set_PB.clicked.connect(lambda: self.RasterizeSet(8))
        self.dlg.DIG_Execute_PB.clicked.connect(lambda: self.Rasterize(8))

        ###### TAB 5.11 - Natural Environment
        self.dlg.ENV_Set_PB.clicked.connect(lambda: self.TypeSet(3))
        self.dlg.ENV_unique_PB.clicked.connect(lambda: self.uniqueValues(3))
        self.dlg.ENV_Execute_PB.clicked.connect(self.natEnvironment)

        self.dlg.ENV_Aggregate_PB.clicked.connect(self.envAggregate)

        ###### TAB 5.12 - Aggregate
        self.dlg.WLK_Aggregate_TB.clicked.connect(lambda: self.getFile(11))
        self.dlg.CYC_Aggregate_TB.clicked.connect(lambda: self.getFile(12))
        self.dlg.APT_Aggregate_TB.clicked.connect(lambda: self.getFile(13))
        self.dlg.SAF_Aggregate_TB.clicked.connect(lambda: self.getFile(14))
        self.dlg.SEC_Aggregate_TB.clicked.connect(lambda: self.getFile(15))
        self.dlg.INC_Aggregate_TB.clicked.connect(lambda: self.getFile(16))
        self.dlg.ELC_Aggregate_TB.clicked.connect(lambda: self.getFile(17))
        self.dlg.LOU_Aggregate_TB.clicked.connect(lambda: self.getFile(18))
        self.dlg.QUH_Aggregate_TB.clicked.connect(lambda: self.getFile(19))
        self.dlg.DIG_Aggregate_TB.clicked.connect(lambda: self.getFile(20))
        self.dlg.ENV_Aggregate_TB.clicked.connect(lambda: self.getFile(21))

        self.dlg.PlaceCharacterization_AggregateExecute_PB.clicked.connect(self.placeCharacterizationAggregation)

        ## TAB 6 - Dimension Aggregation ************************************************************************
        self.dlg.ID_Aggregate_TB.clicked.connect(lambda: self.getFile(22))
        self.dlg.CD_Aggregate_TB.clicked.connect(lambda: self.getFile(23))
        self.dlg.AD_Aggregate_TB.clicked.connect(lambda: self.getFile(24))
        self.dlg.PD_Aggregate_TB.clicked.connect(lambda: self.getFile(25))

        self.dlg.Dimensions_AggregateExecute_PB.clicked.connect(self.dimesnionsAggregation)

    def getFile(self, button_num):
        response = QFileDialog.getOpenFileName(
            parent=self.dlg,
            caption='Select a file',
            directory=os.getcwd()
        )

        if button_num == 0:
            self.dlg.EDU_Aggregate_Field.setText(response[0])

        elif button_num == 1:
            self.dlg.CRE_Aggregate_Field.setText(response[0])

        elif button_num == 2:
            self.dlg.DOV_Aggregate_Field.setText(response[0])

        elif button_num == 3:
            self.dlg.PLP_Aggregate_Field.setText(response[0])

        elif button_num == 4:
            self.dlg.FIN_Aggregate_Field.setText(response[0])

        elif button_num == 5:
            self.dlg.WTP_Aggregate_Field.setText(response[0])

        elif button_num == 6:
            self.dlg.PBT_Aggregate_Field.setText(response[0])

        elif button_num == 7:
            self.dlg.ETF_Aggregate_Field.setText(response[0])

        elif button_num == 8:
            self.dlg.JOB_Aggregate_Field.setText(response[0])

        elif button_num == 9:
            self.dlg.HEA_Aggregate_Field.setText(response[0])

        elif button_num == 10:
            self.dlg.FIF_Aggregate_Field.setText(response[0])

        elif button_num == 11:
            self.dlg.WLK_Aggregate_Field.setText(response[0])

        elif button_num == 12:
            self.dlg.CYC_Aggregate_Field.setText(response[0])

        elif button_num == 13:
            self.dlg.APT_Aggregate_Field.setText(response[0])

        elif button_num == 14:
            self.dlg.SAF_Aggregate_Field.setText(response[0])

        elif button_num == 15:
            self.dlg.SEC_Aggregate_Field.setText(response[0])

        elif button_num == 16:
            self.dlg.INC_Aggregate_Field.setText(response[0])

        elif button_num == 17:
            self.dlg.ELC_Aggregate_Field.setText(response[0])

        elif button_num == 18:
            self.dlg.LOU_Aggregate_Field.setText(response[0])

        elif button_num == 19:
            self.dlg.QUH_Aggregate_Field.setText(response[0])

        elif button_num == 20:
            self.dlg.DIG_Aggregate_Field.setText(response[0])

        elif button_num == 21:
            self.dlg.ENV_Aggregate_Field.setText(response[0])

        elif button_num == 22:
            self.dlg.ID_Aggregate_Field.setText(response[0])

        elif button_num == 23:
            self.dlg.CD_Aggregate_Field.setText(response[0])

        elif button_num == 24:
            self.dlg.AD_Aggregate_Field.setText(response[0])

        elif button_num == 25:
            self.dlg.PD_Aggregate_Field.setText(response[0])

    def getFolder(self, button_num):
        response = QFileDialog.getExistingDirectory(
            parent=self.dlg,
            caption='Select a folder/directory',
            directory=os.getcwd()
        )

        if button_num == 0:
            self.dlg.workingDir_Field.setText(str(response + "/"))

    def saveFile(self,button_num):
        response = QFileDialog.getSaveFileName(
            parent=self.dlg,
            caption='Save file',
            directory=os.getcwd()
        )

        if button_num == 1:
            self.dlg.IDWRasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 2:
            self.dlg.RasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 3:
            self.dlg.serviceAreaOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 4:
            self.dlg.MCAOutputFilePath_Field.setText(str(response[0]))

    def RasterizeSet(self, factor_no):
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.EDU_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.EDU_rasField_CB.addItems(fields)

        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.CRE_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.CRE_rasField_CB.addItems(fields)

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.DOV_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.DOV_rasField_CB.addItems(fields)

        elif factor_no == 3:
            polygonlayer = self.dlg.PLP_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.PLP_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.PLP_rasField_CB.addItems(fields)

        elif factor_no == 4:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.FIN_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.FIN_rasField_CB.addItems(fields)

        elif factor_no == 5:
            polygonlayer = self.dlg.INC_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.INC_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.INC_rasField_CB.addItems(fields)

        elif factor_no == 6:
            polygonlayer = self.dlg.SEC_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.SEC_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.SEC_rasField_CB.addItems(fields)

        elif factor_no == 7:
            polygonlayer = self.dlg.ELC_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.ELC_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.ELC_rasField_CB.addItems(fields)

        elif factor_no == 8:
            polygonlayer = self.dlg.DIG_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.DIG_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.DIG_rasField_CB.addItems(fields)

    def TypeSet(self,factor_no):
        if factor_no == 1:
            roadlayer = self.dlg.WLK_Input_Field.filePath()
            layer = QgsVectorLayer(roadlayer, "polygonlayer", 'ogr')
            self.dlg.WLK_roadTypeField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.WLK_roadTypeField_CB.addItems(fields)

        elif factor_no == 2:
            roadlayer = self.dlg.CYC_Input_Field.filePath()
            layer = QgsVectorLayer(roadlayer, "polygonlayer", 'ogr')
            self.dlg.CYC_roadTypeField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.CYC_roadTypeField_CB.addItems(fields)

        elif factor_no == 3:
            polygonlayer = self.dlg.ENV_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.ENV_riskLevelField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.ENV_riskLevelField_CB.addItems(fields)

    def uniqueValues(self, factor_no):
        if factor_no == 1:
            gdf = gpd.read_file(self.dlg.WLK_Input_Field.filePath())
            roadTypeField = self.dlg.WLK_roadTypeField_CB.currentText()
            uniqueValues = gdf[roadTypeField].unique().tolist()
            scoreList = []

            for val in uniqueValues:
                scoreList.append([val,0])

            self.dlg.WLK_typeScore_Field.setText(str(scoreList))

        elif factor_no == 2:
            gdf = gpd.read_file(self.dlg.CYC_Input_Field.filePath())
            roadTypeField = self.dlg.CYC_roadTypeField_CB.currentText()
            self.dlg.CYC_roadType_CB.clear()
            uniqueValues = gdf[roadTypeField].unique().tolist()
            self.dlg.CYC_roadType_CB.addItems(uniqueValues)

        if factor_no == 3:
            gdf = gpd.read_file(self.dlg.ENV_Input_Field.filePath())
            riskTypeField = self.dlg.ENV_riskLevelField_CB.currentText()
            uniqueValues = gdf[riskTypeField].unique().tolist()
            scoreList = []

            for val in uniqueValues:
                scoreList.append([val,0])

            self.dlg.ENV_typeScore_Field.setText(str(scoreList))

    def convertCRS(self, vector, UTM_crs):
        global shp_utm

        shp = gpd.read_file(vector)
        shp_wgs84 = shp.to_crs('EPSG:4326')
        shp_utm = shp_wgs84.to_crs(UTM_crs)

# *************************** Geoprocessing Functions ********************************** #
    def Rasterize(self, factor_no):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        #INPUT
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            rasField = self.dlg.EDU_rasField_CB.currentText()

        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            rasField = self.dlg.CRE_rasField_CB.currentText()

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            rasField = self.dlg.DOV_rasField_CB.currentText()

        elif factor_no == 3:
            polygonlayer = self.dlg.PLP_Input_Field.filePath()
            rasField = self.dlg.PLP_rasField_CB.currentText()

        elif factor_no == 4:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            rasField = self.dlg.FIN_rasField_CB.currentText()

        elif factor_no == 5:
            polygonlayer = self.dlg.INC_Input_Field.filePath()
            rasField = self.dlg.INC_rasField_CB.currentText()

        elif factor_no == 6:
            polygonlayer = self.dlg.SEC_Input_Field.filePath()
            rasField = self.dlg.SEC_rasField_CB.currentText()

        elif factor_no == 7:
            polygonlayer = self.dlg.ELC_Input_Field.filePath()
            rasField = self.dlg.ELC_rasField_CB.currentText()

        elif factor_no == 8:
            polygonlayer = self.dlg.DIG_Input_Field.filePath()
            rasField = self.dlg.DIG_rasField_CB.currentText()


        # Convert countryLayer data to UTM CRS
        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer =  QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                         'DISTANCE': 2000,
                                         'SEGMENTS': 5,
                                         'END_CAP_STYLE': 0,
                                         'JOIN_STYLE': 0,
                                         'MITER_LIMIT': 2,
                                         'DISSOLVE': True,
                                         'SEPARATE_DISJOINT': False,
                                         'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        # Convert spatial data to UTM CRS
        self.convertCRS(polygonlayer, UTM_crs)
        Rmax = 100
        Rmin = 0
        m_max = 5
        m_min = 0
        if factor_no == 0:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Individual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.EDU_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.EDU_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 1:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax)/(Rmin - Rmax) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Individual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.CRE_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.CRE_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 2:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax)/(Rmin - Rmax) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Individual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.DOV_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.DOV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 3:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Contextual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.PLP_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.PLP_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 4:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Contextual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.FIN_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.FIN_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 5:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.INC_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.INC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 6:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax)/(Rmin - Rmax) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            Output_Folder = "SEC"
            if os.path.exists(Output_Folder):
                os.chdir(Output_Folder)
            else:
                os.mkdir(Output_Folder)
                os.chdir(Output_Folder)


            rasOutput = self.dlg.SEC_incidentOutput_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.DOV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/{Output_Folder}"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 7:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.ELC_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.ELC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        elif factor_no == 8:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.DIG_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.DIG_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

    def IDW(self):

        workingDir = self.dlg.workingDir_Field.text()
        tempDir = workingDir + "temp"
        os.mkdir(tempDir)

        #INPUT
        countryAdminLayer = self.dlg.countryLayer_Field.filePath()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]
        FaciltyPointlayer = self.dlg.pointLayer_Field.filePath()
        bufferDistance = self.dlg.bufferDistance_spinBox.value()
        pixelSize = self.dlg.pixelSize_spinBox.value()

        # OUTPUT
        countryAdminLayer_utm_otput = f"{tempDir}/Admin0_UTM.shp"
        FaciltyPoint_utm_output = f"{tempDir}/university_UTM.shp"
        lineToPoint_output = f"{tempDir}/lineToPoint.shp"
        mergedPoints_output = f"{tempDir}/mergedPoints.shp"
        finalOutput = self.dlg.IDWRasterOutputFilePath_Field.text()

        # Convert spatial data to UTM CRS
        self.convertCRS(countryAdminLayer, UTM_crs)
        shp_utm.to_file(countryAdminLayer_utm_otput)

        self.convertCRS(FaciltyPointlayer, UTM_crs)
        shp_utm["EScore"] = 5
        shp_utm.to_file(FaciltyPoint_utm_output)

        #Geoprocessing Algorithms
        buffer = processing.run("native:buffer", {'INPUT': FaciltyPoint_utm_output,
                                                  'DISTANCE': bufferDistance,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'OUTPUT': "memory:"})
        bufferOutput = buffer["OUTPUT"]

        polyToLine = processing.run("native:polygonstolines", {'INPUT':bufferOutput,
                                                               'OUTPUT': "memory:"})

        polyToLineOutput = polyToLine["OUTPUT"]

        lineToPoint =  processing.run("native:pointsalonglines", {'INPUT':polyToLineOutput,
                                                                  'DISTANCE':1000,
                                                                  'START_OFFSET':0,
                                                                  'END_OFFSET':0,
                                                                  'OUTPUT': lineToPoint_output})


        lineToPoint_shp = gpd.read_file(lineToPoint_output)
        lineToPoint_shp["EScore"] = 0

        merged_gdf = pd.concat([shp_utm, lineToPoint_shp], ignore_index=True)
        merged_gdf.to_file(mergedPoints_output)

        layer = QgsVectorLayer(mergedPoints_output, "mergedPoints", 'ogr')
        desired_field = 'EScore'
        field_index = layer.fields().indexFromName(desired_field)

        IDW = processing.run("qgis:idwinterpolation", {'INTERPOLATION_DATA': mergedPoints_output + f"::~::0::~::{field_index}::~::0",     #'C:/Users/Andre/Nextcloud/GIS_WBGIT/QGIS_WBGIT/test.shp::~::0::~::3::~::0'
                                                       'DISTANCE_COEFFICIENT': 2,
                                                       'EXTENT': '306969.217500000,450078.884900000,8626350.630799999,8743170.112700000 [EPSG:32738]',
                                                       'PIXEL_SIZE': pixelSize,
                                                       'OUTPUT': finalOutput})


        layer = QgsRasterLayer(finalOutput, f"{finalOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

        QMessageBox.information(self.dlg, "Message", f"IDW interpolated raster file has been created /n CRS EPSG:{UTM_crs} /threshold Distance {bufferDistance}m")

    def ServiceArea(self, factor_no):
            current_script_path = os.path.dirname(os.path.abspath(__file__))
            workingDir = self.dlg.workingDir_Field.text()
            os.chdir(workingDir)
            tempDir = "temp"
            Dimension = "Accessibility"

            if os.path.exists(Dimension):
                pass
            else:
                os.mkdir(Dimension)

            if os.path.exists(tempDir):
                shutil.rmtree(tempDir)
            else:
                pass

            time.sleep(0.5)
            os.mkdir(tempDir)


            UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
            countryLayer = self.dlg.countryLayer_Field.filePath()
            pixelSize = self.dlg.pixelSize_SB.value()

            # INPUT
            if factor_no == 0:
                FaciltyPointlayer = self.dlg.PBT_Input_Field.filePath()
                ranges = self.dlg.PBT_Ranges_Field.text()
                rasOutput = self.dlg.PBT_Output_Field.text()
                mergeOutput = f"{workingDir}{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{rasOutput.split('.')[0]}.qml"


                self.dlg.PBT_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

                if self.dlg.PBT_mode_CB.currentText() == "Driving":
                    mode = 0
                elif self.dlg.PBT_mode_CB.currentText() == "Walking":
                    mode = 6

                if self.dlg.PBT_measurement_CB.currentText() == "Time":
                    measurement = 0
                    ranges_field = "AA_MINS"
                elif self.dlg.PBT_measurement_CB.currentText() == "Distance":
                    measurement = 1
                    ranges_field = "AA_METERS"

            elif factor_no == 1:
                FaciltyPointlayer = self.dlg.ETF_Input_Field.filePath()
                ranges = self.dlg.ETF_Ranges_Field.text()
                rasOutput = self.dlg.ETF_Output_Field.text()
                mergeOutput = f"{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{rasOutput.split('.')[0]}.qml"

                self.dlg.ETF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

                if self.dlg.ETF_mode_CB.currentText() == "Driving":
                    mode = 0
                elif self.dlg.ETF_mode_CB.currentText() == "Walking":
                    mode = 6

                if self.dlg.ETF_measurement_CB.currentText() == "Time":
                    measurement = 0
                    ranges_field = "AA_MINS"
                elif self.dlg.ETF_measurement_CB.currentText() == "Distance":
                    measurement = 1
                    ranges_field = "AA_METERS"

            elif factor_no == 2:
                FaciltyPointlayer = self.dlg.JOB_Input_Field.filePath()
                ranges = self.dlg.JOB_Ranges_Field.text()
                rasOutput = self.dlg.JOB_Output_Field.text()
                mergeOutput = f"{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{rasOutput.split('.')[0]}.qml"

                self.dlg.JOB_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

                if self.dlg.JOB_mode_CB.currentText() == "Driving":
                    mode = 0
                elif self.dlg.JOB_mode_CB.currentText() == "Walking":
                    mode = 6

                if self.dlg.JOB_measurement_CB.currentText() == "Time":
                    measurement = 0
                    ranges_field = "AA_MINS"
                elif self.dlg.JOB_measurement_CB.currentText() == "Distance":
                    measurement = 1
                    ranges_field = "AA_METERS"

            elif factor_no == 3:
                FaciltyPointlayer = self.dlg.HEA_Input_Field.filePath()
                ranges = self.dlg.HEA_Ranges_Field.text()
                rasOutput = self.dlg.HEA_Output_Field.text()
                mergeOutput = f"{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{rasOutput.split('.')[0]}.qml"

                self.dlg.HEA_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

                if self.dlg.HEA_mode_CB.currentText() == "Driving":
                    mode = 0
                elif self.dlg.HEA_mode_CB.currentText() == "Walking":
                    mode = 6

                if self.dlg.HEA_measurement_CB.currentText() == "Time":
                    measurement = 0
                    ranges_field = "AA_MINS"
                elif self.dlg.HEA_measurement_CB.currentText() == "Distance":
                    measurement = 1
                    ranges_field = "AA_METERS"

            elif factor_no == 4:
                FaciltyPointlayer = self.dlg.FIF_Input_Field.filePath()
                ranges = self.dlg.FIF_Ranges_Field.text()
                rasOutput = self.dlg.FIF_Output_Field.text()
                mergeOutput = f"{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{rasOutput.split('.')[0]}.qml"

                self.dlg.FIF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

                if self.dlg.FIF_mode_CB.currentText() == "Driving":
                    mode = 0
                elif self.dlg.FIF_mode_CB.currentText() == "Walking":
                    mode = 6

                if self.dlg.FIF_measurement_CB.currentText() == "Time":
                    measurement = 0
                    ranges_field = "AA_MINS"
                elif self.dlg.FIF_measurement_CB.currentText() == "Distance":
                    measurement = 1
                    ranges_field = "AA_METERS"

            elif factor_no == 5:
                FaciltyPointlayer = self.dlg.WTP_Input_Field.filePath()
                ranges = self.dlg.WTP_Ranges_Field.text()
                rasOutput = self.dlg.WTP_FacilityOutput_Field.text()
                mergeOutput = f"{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"


                if self.dlg.WTP_mode_CB.currentText() == "Driving":
                    mode = 0
                elif self.dlg.WTP_mode_CB.currentText() == "Walking":
                    mode = 6

                if self.dlg.WTP_measurement_CB.currentText() == "Time":
                    measurement = 0
                    ranges_field = "AA_MINS"
                elif self.dlg.WTP_measurement_CB.currentText() == "Distance":
                    measurement = 1
                    ranges_field = "AA_METERS"

            #OUTPUT
            SAOutput_utm = f"{tempDir}/SA_OUTPUT_UTM.shp"
            # mergeOutput = f"{tempDir}/{}.shp"



            gdf = gpd.read_file(FaciltyPointlayer)

            subset_size = 5
            subsets = []

            for i in range(0, len(gdf), subset_size):
                subset = gdf.iloc[i:i + subset_size]
                subset = QgsVectorLayer(subset.to_json(), "mygeojson", "ogr")
                subset_outfile = f"{tempDir}/SA_subset_{i + subset_size}.shp"


                Service_Area = processing.run("ORS Tools:isochrones_from_layer", {'INPUT_PROVIDER': 0,
                                                                                  'INPUT_PROFILE': mode,
                                                                                  'INPUT_POINT_LAYER': subset,
                                                                                  'INPUT_FIELD': '',
                                                                                  'INPUT_METRIC': measurement,
                                                                                  'INPUT_RANGES': ranges,
                                                                                  'INPUT_AVOID_FEATURES': [],
                                                                                  'INPUT_AVOID_BORDERS': None,
                                                                                  'INPUT_AVOID_COUNTRIES': '',
                                                                                  'INPUT_AVOID_POLYGONS': None,
                                                                                  'OUTPUT': subset_outfile})
                subsets.append(subset_outfile)



            Merge = processing.run("native:mergevectorlayers", {'LAYERS': subsets,
                                                                'CRS': QgsCoordinateReferenceSystem(UTM_crs),
                                                                'OUTPUT': SAOutput_utm})


            SA_df = gpd.read_file(SAOutput_utm)
            no_spaces_string = "".join(ranges.split())
            ranges_list = no_spaces_string.split(",")
            int_ranges_list = [int(x) for x in ranges_list]
            int_ranges_list.sort()

            range_subsets = []

            for i in int_ranges_list:
                range_subset = SA_df[SA_df[ranges_field] == i]
                range_subset = QgsVectorLayer(range_subset.to_json(), f"range_{i}", "ogr")

                dissolve = processing.run("native:dissolve", {'INPUT': range_subset,
                                                              'FIELD':[],
                                                              'SEPARATE_DISJOINT':False,
                                                              'OUTPUT':"memory:"})

                Range_output = dissolve["OUTPUT"]

                range_subsets.append(range_subset)

            Merge_list = []
            len_range = len(range_subsets)
            # int_ranges_list.sort(reverse=True)
            for i in range(-1, -len(range_subsets), -1):
                output = f"{tempDir}/band_dif_{int_ranges_list[i]}_-_{int_ranges_list[i-1]}.shp"
                # Merge_list.append(output)
                difference = processing.run("native:difference", {'INPUT': range_subsets[i],
                                                                  'OVERLAY': range_subsets[i-1],
                                                                  'OUTPUT': "memory:",
                                                                  'GRID_SIZE': None})
                diff_output = difference["OUTPUT"]

                dissolve = processing.run("native:dissolve", {'INPUT': diff_output,
                                                              'FIELD': [],
                                                              'SEPARATE_DISJOINT': False,
                                                              'OUTPUT': "memory:"})

                dis_output = dissolve["OUTPUT"]
                Merge_list.append(dis_output)



            dissolve = processing.run("native:dissolve", {'INPUT': range_subsets[0],
                                                          'FIELD': [],
                                                          'SEPARATE_DISJOINT': False,
                                                          'OUTPUT': "memory:"})

            dis_output = dissolve["OUTPUT"]
            Merge_list.append(dis_output)

            if os.path.exists(f"{Dimension}/SA_SHP"):
                pass
            else:
                os.mkdir(f"{Dimension}/SA_SHP")

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': Merge_list,
                                                                'CRS':None,
                                                                'OUTPUT':mergeOutput})


            merge_df = gpd.read_file(mergeOutput)
            merge_df["rasField"] = [1,2,3,4,5]
            merge_SA_UTM = QgsVectorLayer(merge_df.to_json(), "merge_SA_utm", "ogr")
            # merge_df.to_file(mergeRasfield)
            # mergelayer = workingDir + mergeRasfield
            # finalMerge = workingDir + finalMerge

            # Convert countryLayer data to UTM CRS
            self.convertCRS(countryLayer, UTM_crs)
            shp_utm["rasField"] = [0]
            shp_utm_ = QgsVectorLayer(shp_utm.to_json(), "shp_utm", "ogr")
            # shp_utm.to_file(countryUTMLayer)

            buffer = processing.run("native:buffer", {'INPUT': shp_utm_,
                                             'DISTANCE': 2000,
                                             'SEGMENTS': 5,
                                             'END_CAP_STYLE': 0,
                                             'JOIN_STYLE': 0,
                                             'MITER_LIMIT': 2,
                                             'DISSOLVE': True,
                                             'SEPARATE_DISJOINT': False,
                                             'OUTPUT': "memory:"})

            buffer_output = buffer["OUTPUT"]

            Difference = processing.run("native:difference", {'INPUT': buffer_output,
                                                              'OVERLAY':merge_SA_UTM,
                                                              'OUTPUT':"memory:",
                                                              'GRID_SIZE':None})

            diff_output = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [merge_SA_UTM, diff_output],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            merge_output = Merge["OUTPUT"]

            # Get the width and height of the extent
            # layer = QgsVectorLayer(finalMerge, 'Polygon Layer', 'ogr')
            extent = merge_output.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)


            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            if factor_no == 5:
                Output_Folder = "WTP"
                if os.path.exists(Output_Folder):
                    os.chdir(Output_Folder)
                else:
                    os.mkdir(Output_Folder)
                    os.chdir(Output_Folder)

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/{Output_Folder}"
                styleFile = f"{rasOutput.split('.')[0]}.qml"
            else:
                pass

            rasterize = processing.run("gdal:rasterize", {'INPUT': merge_output,
                                                          'FIELD': "rasField",
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))


            QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

    def wtpAggregate(self):
        # OUTPUT
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        Dimension = "Accessibility"
        WTP_Folder = f"{Dimension}/WTP"

        if os.path.exists(WTP_Folder):
            os.chdir(WTP_Folder)
        else:
            pass

        rasOutput = self.dlg.WTP_AGGOutput_Field.text()

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        tif_list = [f for f in os.listdir(os.getcwd()) if f.endswith('.tif')]
        raster_list = []

        for ras in tif_list:
            with rasterio.open(ras) as src:
                raster_list.append(src.read(1))
                meta1 = src.meta

        len_raster_list = len(raster_list)
        cumulative_sum = 0

        for i in range(len_raster_list):
            value = raster_list[i]
            cumulative_sum += value

        aggregation = cumulative_sum / len_raster_list
        os.chdir("..")

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(aggregation, 1)

        self.dlg.WTP_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

        os.chdir(workingDir)

    def secAggregate(self):
        # OUTPUT
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        Dimension = "Place Characterization"
        SEC_Folder = f"{Dimension}/SEC"

        if os.path.exists(SEC_Folder):
            os.chdir(SEC_Folder)
        else:
            pass

        rasOutput = self.dlg.SEC_AGGOutput_Field.text()

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        tif_list = [f for f in os.listdir(os.getcwd()) if f.endswith('.tif')]
        raster_list = []

        for ras in tif_list:
            with rasterio.open(ras) as src:
                raster_list.append(src.read(1))
                meta1 = src.meta

        len_raster_list = len(raster_list)
        cumulative_sum = 0

        for i in range(len_raster_list):
            value = raster_list[i]
            cumulative_sum += value

        aggregation = cumulative_sum / len_raster_list
        os.chdir("..")

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(aggregation, 1)

        self.dlg.SEC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

        os.chdir(workingDir)

    def walkability(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        lineLayer = self.dlg.WLK_Input_Field.filePath()
        roadTypeField = self.dlg.WLK_roadTypeField_CB.currentText()
        roadType_Score = ast.literal_eval(self.dlg.WLK_typeScore_Field.text())
        rasField = "Score"

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        scoredRoads = f"{workingDir}/{tempDir}/Scored_roads.shp"

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        self.convertCRS(lineLayer, UTM_crs)
        shp_utm[rasField] = ''


        for i in roadType_Score:
            shp_utm.loc[shp_utm[roadTypeField] == i[0], 'Score'] = i[1]

        shp_utm[rasField] = shp_utm[rasField].astype(int)
        shp_utm.to_file(scoredRoads)

        # scoredRoadsUTM = QgsVectorLayer(shp_utm.to_json(), "linebufUTM", "ogr")
        roadBuf_out = f"{workingDir}/{tempDir}/roadBuf.shp"

        Buffer = processing.run("gdal:buffervectors",{'INPUT': scoredRoads,
                                             'GEOMETRY': 'geometry',
                                             'DISTANCE': 250,
                                             'FIELD': roadTypeField,
                                             'DISSOLVE': False,
                                             'EXPLODE_COLLECTIONS': False,
                                             'OPTIONS': '',
                                             'OUTPUT': roadBuf_out})

        dif_out = f"{workingDir}/{tempDir}/Dif.shp"

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': roadBuf_out,
                                                          'OUTPUT': dif_out,
                                                          'GRID_SIZE': None})

        # difference = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [roadBuf_out, dif_out],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        # Get the width and height of the extent
        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)
        rasOutput = self.dlg.WLK_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.WLK_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

        os.chdir(workingDir)

    def nightTimeLights(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        Dimension = "Place Characterization"


        NTL_input = self.dlg.SAF_Input_Field.filePath()
        rasOutput_temp = "temp_" + self.dlg.SAF_Output_Field.text()
        rasOutput = self.dlg.SAF_Output_Field.text()

        # styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        # styleFileDestination = f"{workingDir}{Dimension}/"
        # styleFile = f"{rasOutput.split('.')[0]}.qml"
        #
        # shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))



        with rasterio.open(NTL_input) as src:
            SAF_ras = src.read(1)
            meta1 = src.meta
            Rmax = SAF_ras.max().astype(float)
            Rmin = SAF_ras.min().astype(float)
            denom = Rmax - Rmin
            m_max = 5
            m_min = 0

        QMessageBox.information(self.dlg, "Message", f"{SAF_ras}, {Rmax}, {Rmin}, {denom}")

        # processing.run("gdal:rastercalculator", {
        #     'INPUT_A': NTL_input,
        #     'BAND_A': 1, 'INPUT_B': None, 'BAND_B': None, 'INPUT_C': None, 'BAND_C': None, 'INPUT_D': None,
        #     'BAND_D': None, 'INPUT_E': None, 'BAND_E': None, 'INPUT_F': None, 'BAND_F': None, 'FORMULA': f'(A-{Rmin})*{m_max}',
        #     'NO_DATA': None, 'EXTENT_OPT': 0, 'PROJWIN': None, 'RTYPE': 5, 'OPTIONS': '', 'EXTRA': '',
        #     'OUTPUT': rasOutput_temp})
        #
        # processing.run("gdal:rastercalculator", {
        #     'INPUT_A': rasOutput_temp,
        #     'BAND_A': 1, 'INPUT_B': None, 'BAND_B': None, 'INPUT_C': None, 'BAND_C': None, 'INPUT_D': None,
        #     'BAND_D': None, 'INPUT_E': None, 'BAND_E': None, 'INPUT_F': None, 'BAND_F': None,
        #     'FORMULA': f'(A/{denom}',
        #     'NO_DATA': None, 'EXTENT_OPT': 0, 'PROJWIN': None, 'RTYPE': 5, 'OPTIONS': '', 'EXTRA': '',
        #     'OUTPUT': rasOutput})

        # Raster Calculation

        # processing.run("qgis:rastercalculator",
        #                {'EXPRESSION': '"NightTimeLights_Comoros_UTM@1" + "NightTimeLights_Comoros_UTM@1"',
        #                 'LAYERS': ['C:/Users/Andre/Documents/NightTimeLights/NightTimeLights_Comoros_UTM.tif'],
        #                 'CELLSIZE': 0, 'EXTENT': None, 'CRS': QgsCoordinateReferenceSystem('EPSG:32738'),
        #                 'OUTPUT': 'TEMPORARY_OUTPUT'})


        # # result = SAF_ras - Rmin
        # # # result = np.divide(result,Rmax)
        # result = (SAF_ras * m_max)
        # QMessageBox.information(self.dlg, "Message", f"{SAF_ras}, {result}")
        #
        # meta1.update(dtype=rasterio.float32)
        #
        # if os.path.exists(Dimension):
        #     os.chdir(Dimension)
        # else:
        #     os.mkdir(Dimension)
        #     os.chdir(Dimension)
        #
        # with rasterio.open(rasOutput, 'w', **meta1) as dst:
        #     dst.write(result, 1)
        #
        # self.dlg.SAF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        os.chdir(workingDir)

    def transportCount(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        hexSize = self.dlg.APT_hexSize_SB.value()
        pointLayer = self.dlg.APT_pointInput_Field.filePath()

        rasField = "Score"

        #TempOutput
        pointCount_out = f"{tempDir}/pointCountPoly.shp"
        adminUTMLayer = f"{tempDir}/adminUTMLayer.shp"
        pointUTMLayer = f"{tempDir}/pointUTMLayer.shp"
        pointCount_std = f"{tempDir}/pointCount_std.shp"


        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]


        country_extent = shp_utm.total_bounds


        Grid = processing.run("native:creategrid", {'TYPE': 4, 'EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
                                                    'HSPACING': hexSize, 'VSPACING': hexSize, 'HOVERLAY': 0, 'VOVERLAY': 0,
                                                    'CRS': QgsCoordinateReferenceSystem(f'{UTM_crs}'),
                                                    'OUTPUT': "memory:"})
        grid_out = Grid["OUTPUT"]

        Clip = processing.run("native:clip", {'INPUT': grid_out,
                                                'OVERLAY': countryUTMLayer,
                                                'OUTPUT': adminUTMLayer})

        self.convertCRS(pointLayer, UTM_crs)
        shp_utm.to_file(pointUTMLayer)


        pointCount = processing.run("native:countpointsinpolygon",{'POLYGONS': QgsProcessingFeatureSourceDefinition(adminUTMLayer,
                                                                   selectedFeaturesOnly = False,
                                                                   featureLimit = -1,
                                                                   flags = QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                                   geometryCheck = QgsFeatureRequest.GeometrySkipInvalid),
                                                                  'POINTS': pointUTMLayer,
                                                                  'WEIGHT': '',
                                                                  'CLASSFIELD': '',
                                                                  'FIELD': rasField,
                                                                  'OUTPUT': pointCount_out})


        pointCount_out_df = gpd.read_file(pointCount_out)

        Rmax = pointCount_out_df[rasField].max()
        Rmin = pointCount_out_df[rasField].min()
        m_max = 5
        m_min = 0

        pointCount_out_df[rasField] = (pointCount_out_df[rasField] - Rmin) / (Rmax - Rmin) * m_max
        pointCount_out_df.to_file(pointCount_std)

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': pointCount_std,
                                                          'OUTPUT': "memory:",
                                                          'GRID_SIZE': None})

        difference = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [pointCount_std, difference],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)

        rasOutput = self.dlg.APT_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.APT_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

        os.chdir(workingDir)

    def cycleways(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        hexSize = self.dlg.CYC_hexSize_SB.value()
        lineLayer = self.dlg.CYC_Input_Field.filePath()
        roadTypeField = self.dlg.CYC_roadTypeField_CB.currentText()
        cycleType = self.dlg.CYC_roadType_CB.currentText()
        rasField = "Perc"


        #TempFiles
        scoredRoads = f"{workingDir}/{tempDir}/Scored_roads.shp"
        adminUTMLayer = f"{tempDir}/adminUTMLayer.shp"
        roadOutput = f"{tempDir}/roadOutput.shp"
        hexOutput = f"{tempDir}/hexOutput.shp"
        hexPercOutput = f"{tempDir}/hexPercOutput.shp"
        roadsUTM = f"{tempDir}/roadsUTM.shp"


        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")



        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        country_extent = shp_utm.total_bounds

        Grid = processing.run("native:creategrid", {'TYPE': 4,
                                                    'EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
                                                    'HSPACING': hexSize, 'VSPACING': hexSize, 'HOVERLAY': 0,
                                                    'VOVERLAY': 0,
                                                    'CRS': QgsCoordinateReferenceSystem(f'{UTM_crs}'),
                                                    'OUTPUT': "memory:"})
        grid_out = Grid["OUTPUT"]

        Clip = processing.run("native:clip", {'INPUT': grid_out,
                                              'OVERLAY': countryUTMLayer,
                                              'OUTPUT': adminUTMLayer})

        self.convertCRS(lineLayer, UTM_crs)
        shp_utm.to_file(roadsUTM)
        #
        # shp_utm.loc[shp_utm[roadTypeField] == cycleType, 'Score'] = 5
        #
        # shp_utm[rasField] = shp_utm[rasField].astype(int)
        # shp_utm.to_file(scoredRoads)

        hex_gdf = gpd.read_file(adminUTMLayer)
        len_hex_gdf = len(hex_gdf)

        road_merge_list = []
        hex_merge_list = []

        for i in range(len_hex_gdf):
            hex_file_name = f"{tempDir}/hex_{i}.shp"
            rec = hex_gdf.iloc[i:i+1]
            hex_gdf.loc[i, 'layer'] = f"hex_{i}_roads"
            hex_merge_list.append(rec)
            rec.to_file(hex_file_name)


            hex_roads_file_name = f"{tempDir}/hex_{i}_roads.shp"

            processing.run("native:clip", {'INPUT': roadsUTM,
                                           'OVERLAY': hex_file_name,
                                           'OUTPUT': hex_roads_file_name})

            hex_road = gpd.read_file(hex_roads_file_name)
            hex_road["hex"] = ""
            hex_road.loc[0, 'hex'] = f"hex_{i}"
            hex_road.to_file(hex_roads_file_name)
            road_merge_list.append(hex_roads_file_name)

        processing.run("native:mergevectorlayers", {'LAYERS': road_merge_list,
                                                    'CRS': QgsCoordinateReferenceSystem(f'{UTM_crs}'),
                                                    'OUTPUT': roadOutput})

        merged_shapefile = gpd.pd.concat(hex_merge_list, ignore_index=True)
        merged_shapefile.to_file(hexOutput)

        merge_gdf = gpd.read_file(roadOutput)
        line_geometries = merge_gdf['geometry']
        merge_gdf['length'] = line_geometries.length
        merge_gdf.to_file(roadOutput)

        grouped = merge_gdf.groupby('layer')
        total_sum_of_groups = grouped['length'].sum()
        total_sum_of_groups_df = total_sum_of_groups.reset_index()

        filtered_df = merge_gdf[merge_gdf[roadTypeField] == cycleType]

        grouped2 = filtered_df.groupby('layer')
        cycleway_sum_of_groups = grouped2['length'].sum()
        cycleway_sum_of_groups_df = cycleway_sum_of_groups.reset_index()

        merged = pd.merge(total_sum_of_groups_df, cycleway_sum_of_groups_df, on=['layer'], how='outer')
        merged_length_gdf = pd.DataFrame(merged)
        merged_length_gdf[rasField] = merged_length_gdf["length_y"] / merged_length_gdf["length_x"] * 100

        hex_gdf = gpd.read_file(hexOutput)
        merge_hex_gdf = hex_gdf.merge(merged_length_gdf, on='layer')

        # merge_hex_gdf.to_file(hexPercOutput)

        ########################################

        Rmax = 100
        Rmin = 0
        m_max = 5
        m_min = 0

        merge_hex_gdf[rasField] = (merge_hex_gdf[rasField] - Rmin) / (Rmax - Rmin) * m_max
        merge_hex_gdf.to_file(hexPercOutput)

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': hexPercOutput,
                                                          'OUTPUT': "memory:",
                                                          'GRID_SIZE': None})

        difference = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [hexPercOutput, difference],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)

        rasOutput = self.dlg.CYC_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.CYC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

    def housing(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        hexSize = self.dlg.QUH_hexSize_SB.value()
        buildingFootprints = self.dlg.QUH_Input_Field.filePath()
        rasField = "Perc"

        # TempFiles
        scoredRoads = f"{workingDir}/{tempDir}/Scored_roads.shp"
        adminUTMLayer = f"{tempDir}/adminUTMLayer.shp"
        buildingOutput = f"{tempDir}/buildingOutput.shp"
        hexOutput = f"{tempDir}/hexOutput.shp"
        hexPercOutput = f"{tempDir}/hexPercOutput.shp"
        buildingFootprintsUTM = f"{tempDir}/buildingFootprintsUTM.shp"

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        country_extent = shp_utm.total_bounds

        Grid = processing.run("native:creategrid", {'TYPE': 4,
                                                    'EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
                                                    'HSPACING': hexSize, 'VSPACING': hexSize, 'HOVERLAY': 0,
                                                    'VOVERLAY': 0,
                                                    'CRS': QgsCoordinateReferenceSystem(f'{UTM_crs}'),
                                                    'OUTPUT': "memory:"})
        grid_out = Grid["OUTPUT"]

        Clip = processing.run("native:clip", {'INPUT': grid_out,
                                              'OVERLAY': countryUTMLayer,
                                              'OUTPUT': adminUTMLayer})

        self.convertCRS(buildingFootprints, UTM_crs)
        shp_utm.to_file(buildingFootprintsUTM)

        hex_gdf = gpd.read_file(adminUTMLayer)
        len_hex_gdf = len(hex_gdf)

        building_merge_list = []
        hex_merge_list = []

        for i in range(len_hex_gdf):
            hex_file_name = f"{tempDir}/hex_{i}.shp"
            rec = hex_gdf.iloc[i:i + 1]
            hex_gdf.loc[i, 'layer'] = f"hex_{i}_buildings"
            hex_merge_list.append(rec)
            rec.to_file(hex_file_name)

            hex_buildings_file_name = f"{tempDir}/hex_{i}_buildings.shp"

            processing.run("native:clip", {'INPUT': QgsProcessingFeatureSourceDefinition(buildingFootprintsUTM,
                                                                                         selectedFeaturesOnly=False,
                                                                                         featureLimit=-1,
                                                                                         flags=QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                                                         geometryCheck=QgsFeatureRequest.GeometrySkipInvalid),
                                           'OVERLAY': hex_file_name,
                                           'OUTPUT': hex_buildings_file_name})

            hex_building = gpd.read_file(hex_buildings_file_name)
            hex_building["layer"] = f"hex_{i}_buildings"
            # hex_building.loc[0, 'hex'] = f"hex_{i}"
            hex_building.to_file(hex_buildings_file_name)
            building_merge_list.append(hex_building)

        # processing.run("native:mergevectorlayers", {'LAYERS': building_merge_list,
        #                                             'CRS': QgsCoordinateReferenceSystem(f'{UTM_crs}'),
        #                                             'OUTPUT': buildingOutput})

        merged_shapefile = gpd.pd.concat(building_merge_list, ignore_index=True)
        merged_shapefile.to_file(buildingOutput)

        merged_shapefile = gpd.pd.concat(hex_merge_list, ignore_index=True)
        merged_shapefile.to_file(hexOutput)

        merge_gdf = gpd.read_file(buildingOutput)
        line_geometries = merge_gdf['geometry']
        merge_gdf['Area'] = line_geometries.area
        merge_gdf['more_60'] = 0
        merge_gdf.loc[merge_gdf['Area'] > 60, 'more_60'] = 1
        merge_gdf.to_file(buildingOutput)

        grouped = merge_gdf.groupby('layer').size().reset_index(name='Total_Count')

        filtered_df = merge_gdf[merge_gdf['more_60'] == 1]

        grouped2 = filtered_df.groupby('layer').size().reset_index(name='More60_Count')

        merged = pd.merge(grouped, grouped2, on=['layer'], how='outer')
        merged_length_gdf = pd.DataFrame(merged)
        merged_length_gdf[rasField] = merged_length_gdf["More60_Count"] / merged_length_gdf["Total_Count"] * 100

        hex_gdf = gpd.read_file(hexOutput)
        merge_hex_gdf = hex_gdf.merge(merged_length_gdf, on='layer', how='outer')


        ############################################################

        Rmax = 100
        Rmin = 0
        m_max = 5
        m_min = 0

        merge_hex_gdf[rasField] = (merge_hex_gdf[rasField] - Rmin) / (Rmax - Rmin) * m_max
        merge_hex_gdf.to_file(hexPercOutput)

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': hexPercOutput,
                                                          'OUTPUT': "memory:",
                                                          'GRID_SIZE': None})

        difference = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [hexPercOutput, difference],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)

        rasOutput = self.dlg.QUH_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.QUH_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

    def natEnvironment(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        polygonLayer = self.dlg.ENV_Input_Field.filePath()
        riskLevelField = self.dlg.ENV_riskLevelField_CB.currentText()
        riskType_Score = ast.literal_eval(self.dlg.ENV_typeScore_Field.text())
        rasField = "Score"

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        scoredRisks = f"{workingDir}/{tempDir}/Scored_risks.shp"

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        self.convertCRS(polygonLayer, UTM_crs)
        shp_utm[rasField] = 0

        for i in riskType_Score:
            # QMessageBox.information(self.dlg, "Message", f"{i}")
            shp_utm.loc[shp_utm[riskLevelField] == i[0], 'Score'] = i[1]

        shp_utm[rasField] = shp_utm[rasField].astype(int)
        shp_utm.to_file(scoredRisks)

        dif_out = f"{workingDir}/{tempDir}/Dif.shp"

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': QgsProcessingFeatureSourceDefinition(scoredRisks,
                                                                                                         selectedFeaturesOnly=False, featureLimit=-1,
                                                                                                         flags=QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                                                                         geometryCheck=QgsFeatureRequest.GeometrySkipInvalid),
                                                          'OUTPUT': dif_out,
                                                          'GRID_SIZE': None})

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [scoredRisks, dif_out],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        # Get the width and height of the extent
        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        if os.path.exists(Dimension):
            os.chdir(Dimension)
        else:
            os.mkdir(Dimension)
            os.chdir(Dimension)

        Output_Folder = "ENV"
        if os.path.exists(Output_Folder):
            os.chdir(Output_Folder)
        else:
            os.mkdir(Output_Folder)
            os.chdir(Output_Folder)

        rasOutput = self.dlg.ENV_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.ENV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/{Output_Folder}"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

    def envAggregate(self):
        # OUTPUT
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        Dimension = "Place Characterization"
        ENV_Folder = f"{Dimension}/ENV"

        if os.path.exists(ENV_Folder):
            os.chdir(ENV_Folder)
        else:
            pass

        rasOutput = self.dlg.ENV_AGGOutput_Field.text()

        styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        tif_list = [f for f in os.listdir(os.getcwd()) if f.endswith('.tif')]
        raster_list = []

        for ras in tif_list:
            with rasterio.open(ras) as src:
                raster_list.append(src.read(1))
                meta1 = src.meta

        len_raster_list = len(raster_list)
        cumulative_sum = 0

        for i in range(len_raster_list):
            value = raster_list[i]
            cumulative_sum += value

        aggregation = cumulative_sum / len_raster_list
        os.chdir("..")

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(aggregation, 1)

        self.dlg.ENV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        QMessageBox.information(self.dlg, "Message", f"Processing Complete!")

    # *************************** Aggregation Functions ************************************ #
    def indivdualAggregation(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)



        #INPUT

        EDU_ras = self.dlg.EDU_Aggregate_Field.text().strip(" ")
        CRE_ras = self.dlg.CRE_Aggregate_Field.text().strip(" ")
        DOV_ras = self.dlg.DOV_Aggregate_Field.text().strip(" ")

        EDU_weight = self.dlg.EDU_Aggregate_SB.value()
        CRE_weight = self.dlg.CRE_Aggregate_SB.value()
        DOV_weight = self.dlg.DOV_Aggregate_SB.value()

        #OUTPUT
        aggregation = self.dlg.Indivdual_AggregateOutput_Field.text()

        rasLayers = [EDU_ras, CRE_ras, DOV_ras]
        factorWeighting = [EDU_weight, CRE_weight, DOV_weight]

        non_empty_count = sum(1 for item in rasLayers if item != "")

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.individualAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:
                with rasterio.open(rasLayers[0]) as src:
                    EDU_ras = src.read(1)
                    EDU_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CRE_ras = src.read(1)
                    CRE_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    DOV_ras = src.read(1)
                    DOV_weight = factorWeighting[2]

                # Raster Calculation

                result = ((EDU_ras * EDU_weight / 100) + (CRE_ras * CRE_weight / 100) + (DOV_ras * DOV_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Individual"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.ID_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerID = logging.getLogger('loggerID')
                loggerID.setLevel(logging.INFO)
                handlerID = logging.FileHandler('Individual.log')
                formatterID = logging.Formatter('%(asctime)s - %(message)s')
                handlerID.setFormatter(formatterID)
                loggerID.addHandler(handlerID)

                loggerID.info(f"Factors: {non_empty_count}/3 - {non_empty_count/3 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Individual dimension aggregation complete!")
            else:
                self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")
        else:
            self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def contextualAggregation(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        PLP_ras = self.dlg.PLP_Aggregate_Field.text().strip(" ")
        FIN_ras = self.dlg.FIN_Aggregate_Field.text().strip(" ")

        PLP_weight = self.dlg.PLP_Aggregate_SB.value()
        FIN_weight = self.dlg.FIN_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.Contextual_AggregateOutput_Field.text()

        rasLayers = [PLP_ras, FIN_ras]
        factorWeighting = [PLP_weight, FIN_weight]
        non_empty_count = sum(1 for item in rasLayers if item != "")

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.contextualAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    PLP_ras = src.read(1)
                    PLP_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    FIN_ras = src.read(1)
                    FIN_weight = factorWeighting[1]


                # Raster Calculation

                result = ((PLP_ras * PLP_weight / 100) + (FIN_ras * FIN_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Contextual"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.CD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerCD = logging.getLogger('loggerCD')
                loggerCD.setLevel(logging.INFO)
                handlerCD = logging.FileHandler('Contextual.log')
                formatterCD = logging.Formatter('%(asctime)s - %(message)s')
                handlerCD.setFormatter(formatterCD)
                loggerCD.addHandler(handlerCD)

                loggerCD.info(f"Factors: {non_empty_count}/2 - {non_empty_count/2 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Contextual dimension aggregation complete!")
            else:
                self.dlg.contextualAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.contextualAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def accessibiltyAggregation(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        #INPUT
        WTP_ras = self.dlg.WTP_Aggregate_Field.text().strip(" ")
        PBT_ras = self.dlg.PBT_Aggregate_Field.text().strip(" ")
        ETF_ras = self.dlg.ETF_Aggregate_Field.text().strip(" ")
        JOB_ras = self.dlg.JOB_Aggregate_Field.text().strip(" ")
        HEA_ras = self.dlg.HEA_Aggregate_Field.text().strip(" ")
        FIF_ras = self.dlg.FIF_Aggregate_Field.text().strip(" ")

        WTP_weight = self.dlg.WTP_Aggregate_SB.value()
        PBT_weight = self.dlg.PBT_Aggregate_SB.value()
        ETF_weight = self.dlg.ETF_Aggregate_SB.value()
        JOB_weight = self.dlg.JOB_Aggregate_SB.value()
        HEA_weight = self.dlg.HEA_Aggregate_SB.value()
        FIF_weight = self.dlg.FIF_Aggregate_SB.value()

        #OUTPUT
        aggregation = self.dlg.Accessibility_AggregateOutput_Field.text()

        rasLayers = [WTP_ras, PBT_ras, ETF_ras, JOB_ras, HEA_ras, FIF_ras]
        factorWeighting = [WTP_weight, PBT_weight, ETF_weight, JOB_weight, HEA_weight, FIF_weight]
        non_empty_count = sum(1 for item in rasLayers if item != "")

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.accessibilityAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:
                with rasterio.open(rasLayers[0]) as src:
                    WTP_ras = src.read(1)
                    WTP_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    PBT_ras = src.read(1)
                    PBT_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    ETF_ras = src.read(1)
                    ETF_weight = factorWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    JOB_ras = src.read(1)
                    JOB_weight = factorWeighting[3]

                with rasterio.open(rasLayers[4]) as src:
                    HEA_ras = src.read(1)
                    HEA_weight = factorWeighting[4]

                with rasterio.open(rasLayers[5]) as src:
                    FIF_ras = src.read(1)
                    FIF_weight = factorWeighting[5]

                # Raster Calculation

                result = ((WTP_ras * WTP_weight / 100) + (PBT_ras * PBT_weight / 100) + (ETF_ras * ETF_weight / 100)
                          + (JOB_ras * JOB_weight / 100) + (HEA_ras * HEA_weight / 100) + (FIF_ras * FIF_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Accessibility"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.AD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerAD = logging.getLogger('loggerAD')
                loggerAD.setLevel(logging.INFO)
                handlerAD = logging.FileHandler('Accessibility.log')
                formatterAD = logging.Formatter('%(asctime)s - %(message)s')
                handlerAD.setFormatter(formatterAD)
                loggerAD.addHandler(handlerAD)

                loggerAD.info(f"Factors: {non_empty_count}/6 - {non_empty_count/6 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Accessibility dimension aggregation complete!")
            else:
                self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")
        else:
            self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def placeCharacterizationAggregation(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        WLK_ras = self.dlg.WLK_Aggregate_Field.text().strip(" ")
        CYC_ras = self.dlg.CYC_Aggregate_Field.text().strip(" ")
        APT_ras = self.dlg.APT_Aggregate_Field.text().strip(" ")
        SAF_ras = self.dlg.SAF_Aggregate_Field.text().strip(" ")
        SEC_ras = self.dlg.SEC_Aggregate_Field.text().strip(" ")
        INC_ras = self.dlg.INC_Aggregate_Field.text().strip(" ")
        ELC_ras = self.dlg.ELC_Aggregate_Field.text().strip(" ")
        LOU_ras = self.dlg.LOU_Aggregate_Field.text().strip(" ")
        QUH_ras = self.dlg.QUH_Aggregate_Field.text().strip(" ")
        DIG_ras = self.dlg.DIG_Aggregate_Field.text().strip(" ")
        ENV_ras = self.dlg.ENV_Aggregate_Field.text().strip(" ")

        WLK_weight = self.dlg.WLK_Aggregate_SB.value()
        CYC_weight = self.dlg.CYC_Aggregate_SB.value()
        APT_weight = self.dlg.APT_Aggregate_SB.value()
        SAF_weight = self.dlg.SAF_Aggregate_SB.value()
        SEC_weight = self.dlg.SEC_Aggregate_SB.value()
        INC_weight = self.dlg.INC_Aggregate_SB.value()
        ELC_weight = self.dlg.ELC_Aggregate_SB.value()
        LOU_weight = self.dlg.LOU_Aggregate_SB.value()
        QUH_weight = self.dlg.QUH_Aggregate_SB.value()
        DIG_weight = self.dlg.DIG_Aggregate_SB.value()
        ENV_weight = self.dlg.ENV_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.PlaceCharacterization_AggregateOutput_Field.text()

        rasLayers = [WLK_ras, CYC_ras, APT_ras, SAF_ras, SEC_ras, INC_ras, ELC_ras, LOU_ras, QUH_ras, DIG_ras, ENV_ras]
        factorWeighting = [WLK_weight, CYC_weight, APT_weight, SAF_weight, SEC_weight, INC_weight, ELC_weight, LOU_weight, QUH_weight, DIG_weight, ENV_weight]
        non_empty_count = sum(1 for item in rasLayers if item != "")


        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.placeCharacterizationAggregation_Check.setText("Factor layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    WLK_ras = src.read(1)
                    WLK_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CYC_ras = src.read(1)
                    CYC_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    APT_ras = src.read(1)
                    APT_weight = factorWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    SAF_ras = src.read(1)
                    SAF_weight = factorWeighting[3]

                with rasterio.open(rasLayers[4]) as src:
                    SEC_ras = src.read(1)
                    SEC_weight = factorWeighting[4]

                with rasterio.open(rasLayers[5]) as src:
                    INC_ras = src.read(1)
                    INC_weight = factorWeighting[5]

                with rasterio.open(rasLayers[6]) as src:
                    ELC_ras = src.read(1)
                    ELC_weight = factorWeighting[6]

                with rasterio.open(rasLayers[7]) as src:
                    LOU_ras = src.read(1)
                    LOU_weight = factorWeighting[7]

                with rasterio.open(rasLayers[8]) as src:
                    QUH_ras = src.read(1)
                    QUH_weight = factorWeighting[8]

                with rasterio.open(rasLayers[9]) as src:
                    DIG_ras = src.read(1)
                    DIG_weight = factorWeighting[9]

                with rasterio.open(rasLayers[10]) as src:
                    ENV_ras = src.read(1)
                    ENV_weight = factorWeighting[10]

                # Raster Calculation

                result = ((WLK_ras * WLK_weight / 100) + (CYC_ras * CYC_weight / 100) + (APT_ras * APT_weight / 100)
                          + (SAF_ras * SAF_weight / 100) + (SEC_ras * SEC_weight / 100) + (INC_ras * INC_weight / 100)
                          + (ELC_ras * ELC_weight / 100) + (LOU_ras * LOU_weight / 100) + (QUH_ras * QUH_weight / 100)
                          + (DIG_ras * DIG_weight / 100) + (ENV_ras * ENV_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Place Characterization"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.PD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerPD = logging.getLogger('loggerPD')
                loggerPD.setLevel(logging.INFO)
                handlerPD = logging.FileHandler('Place Characterization.log')
                formatterPD = logging.Formatter('%(asctime)s - %(message)s')
                handlerPD.setFormatter(formatterPD)
                loggerPD.addHandler(handlerPD)

                loggerPD.info(f"Factors: {non_empty_count}/11 - {non_empty_count / 11 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}\Style\{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Place Characterization dimension aggregation complete!")
            else:
                self.dlg.placeCharacterizationAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.placeCharacterizationAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def dimesnionsAggregation(self):
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        ID_ras = self.dlg.ID_Aggregate_Field.text().strip(" ")
        CD_ras = self.dlg.CD_Aggregate_Field.text().strip(" ")
        AD_ras = self.dlg.AD_Aggregate_Field.text().strip(" ")
        PD_ras = self.dlg.PD_Aggregate_Field.text().strip(" ")

        ID_weight = self.dlg.ID_Aggregate_SB.value()
        CD_weight = self.dlg.CD_Aggregate_SB.value()
        AD_weight = self.dlg.AD_Aggregate_SB.value()
        PD_weight = self.dlg.PD_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.Dimensions_AggregateOutput_Field.text()

        rasLayers = [ID_ras, CD_ras, AD_ras, PD_ras]
        dimensionWeighting = [ID_weight, CD_weight, AD_weight, PD_weight]

        weightingSum = round(sum(dimensionWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                self.dlg.dimensionAggregation_Check.setText("Dimension layer/s missing")
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    dimensionWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(dimensionWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    ID_ras = src.read(1)
                    ID_weight = dimensionWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CD_ras = src.read(1)
                    CD_weight = dimensionWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    AD_ras = src.read(1)
                    AD_weight = dimensionWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    PD_ras = src.read(1)
                    PD_weight = dimensionWeighting[3]


                # Raster Calculation

                result = ((ID_ras * ID_weight / 100) + (CD_ras * CD_weight / 100) + (AD_ras * AD_weight / 100) + (PD_ras * PD_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Final_output = "Final_output"
                if os.path.exists(Final_output):
                    os.chdir(Final_output)
                else:
                    os.mkdir(Final_output)
                    os.chdir(Final_output)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                styleTemplate = f"{current_script_path}\Style\Final.qml"
                styleFileDestination = f"{workingDir}{Final_output}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                log_list = ['Individual', 'Contextual', 'Accessibility', 'Place Characterization']
                factor_num = []

                for dimension in log_list:
                    log_file = f"{workingDir}{dimension}/{dimension}.log"
                    if os.path.exists(log_file):
                        with open(log_file, 'r') as file:
                            lines = file.readlines()

                            if lines:
                                last_line = lines[-1].split("-")[-1].strip()
                            else:
                                pass

                            factor_num.append(last_line)
                    else:
                        pass

                integer_list = [int(item) for item in factor_num]
                sum_list = sum(integer_list)
                Confidence = round(sum_list/22 * 100, 2)
                



                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.information(self.dlg, "Message", f"Dimensional aggregation complete! - Confidence: {sum_list}/22 factors used. ({Confidence} %)")
            else:
                self.dlg.dimensionAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.dimensionAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)
