# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenderIndicatorTool
                                 A QGIS plugin
 Gender Indicator Tool
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-15
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Pegasys
        email                : andre@pegasys.co.za
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# QGIS and PyQt libraries and modules
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from PyQt5.QtWidgets import QFileDialog, QApplication
from qgis.core import *

# Auxiliary libraries
import os
import sys
import geopandas as gpd
import pandas as pd
import rasterio
import numpy as np
import math
import shutil
import time

# Prepare processing framework
sys.path.append(r'C:\Program Files\QGIS 3.32.0\apps\qgis\python\plugins') # Folder where Processing is located
from processing.core.Processing import Processing
Processing.initialize()
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gender_indicator_tool_dialog import GenderIndicatorToolDialog



class GenderIndicatorTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GenderIndicatorTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&World Bank Gender Indicator Tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GenderIndicatorTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gender_indicator_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&World Bank Gender Indicator Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GenderIndicatorToolDialog()

        # show the dialog
        self.dlg.show()


        ## TAB 1 *******************************************************************
        self.dlg.workingDir_Button.clicked.connect(lambda: self.getFolder(1))

        # Setting CRS
        CRS = [["Other", 0],
               ["Comoros", 32738],
               ["Dominican Republic", 32619],
               ["Papua New Guinea", 32755],
               ]
        CRScomboBox_list = [x[0] + " - EPSG: " + str(x[1]) for x in CRS]

        self.dlg.CRS_comboBox.addItems(CRScomboBox_list)

        ## TAB 2 *******************************************************************
        self.dlg.IDWRasterOutputFilePath_Button.clicked.connect(lambda: self.saveFile(1))
        self.dlg.pbIDWExecute.clicked.connect(self.IDW)

        ## TAB 3 *******************************************************************
        self.dlg.rasterSet_Button.clicked.connect(self.RasterizeSet)
        self.dlg.RasterOutputFilePath_Button.clicked.connect(lambda: self.saveFile(2))
        self.dlg.pbRasterizeExecute.clicked.connect(self.Rasterize)

        ## TAB 4 *******************************************************************
        # Setting Travel Mode
        travelModes = ["Driving-car", "Walking"]
        self.dlg.travelMode_comboBox.addItems(travelModes)

        # Setting Measurment Metric
        metric = ["time", "distance"]
        self.dlg.metric_comboBox.addItems(metric)

        self.dlg.serviceAreaOutputFilePath_Button.clicked.connect(lambda: self.saveFile(3))
        self.dlg.pbserviceAreaExecute.clicked.connect(self.ServiceArea)

        ## TAB 5 *******************************************************************
        self.dlg.MCAOutputFilePath_Button.clicked.connect(lambda: self.saveFile(4))
        self.dlg.pbMCAExecute.clicked.connect(self.MCA)

    def getFolder(self, button_num):
        response = QFileDialog.getExistingDirectory(
            parent=self.dlg,
            caption='Select a folder/directory',
            directory=os.getcwd()
        )

        if button_num == 1:
            self.dlg.workingDir_Field.setText(str(response + "/"))

    def saveFile(self,button_num):
        response = QFileDialog.getSaveFileName(
            parent=self.dlg,
            caption='Save file',
            directory=os.getcwd()
        )

        if button_num == 1:
            self.dlg.IDWRasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 2:
            self.dlg.RasterOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 3:
            self.dlg.serviceAreaOutputFilePath_Field.setText(str(response[0]))

        elif button_num == 4:
            self.dlg.MCAOutputFilePath_Field.setText(str(response[0]))

    def RasterizeSet(self):
        polygonlayer = self.dlg.polygonLayer_Field.filePath()
        layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
        self.dlg.rasField_comboBox.clear()
        fields = [field.name() for field in layer.fields()]
        self.dlg.rasField_comboBox.addItems(fields)

    def convertCRS(self, vector, UTM_crs):
        global shp_utm

        shp = gpd.read_file(vector)
        shp_wgs84 = shp.to_crs('EPSG:4326')
        shp_utm = shp_wgs84.to_crs(f'EPSG:{UTM_crs}')

# *************************** Geoprocessing Functions ********************************** #
    def Rasterize(self):

        workingDir = self.dlg.workingDir_Field.text()
        tempDir = workingDir + "temp"
        os.mkdir(tempDir)

        #INPUT
        polygonlayer = self.dlg.polygonLayer_Field.filePath()
        rasField = self.dlg.rasField_comboBox.currentText()
        pixelSize = self.dlg.pixelSize_spinBox_2.value()
        UTM_crs = self.dlg.CRS_comboBox.currentText().split(":")[1].strip()

        #OUTPUT
        polygonUTM = f"{tempDir}/polygonLayer_UTM.shp"
        rasterizeOutput = f"{tempDir}/polygonRas.tif"
        rasOutput = self.dlg.RasterOutputFilePath_Field.text()

        # Convert spatial data to UTM CRS
        self.convertCRS(polygonlayer, UTM_crs)
        shp_utm.to_file(polygonUTM)

        # Get the width and height of the extent
        layer = QgsVectorLayer(polygonUTM, 'Polygon Layer', 'ogr')
        extent = layer.extent()
        raster_width = int(extent.width() / pixelSize) + 1
        raster_height = int(extent.height() / pixelSize) + 1

        rasterize = processing.run("gdal:rasterize", {'INPUT': polygonlayer,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': 0,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasterizeOutput})


        rasterizeOutput = rasterize["OUTPUT"]

        # *************************** Standardization **********************************
        with rasterio.open(rasterizeOutput) as src:
            data = src.read(1)
            meta = src.meta

        # Raster Calculation
        result = (data - 0)/(100 - 0) * 5

        meta.update(dtype=rasterio.float32)

        with rasterio.open(rasOutput, 'w', **meta) as dst:
            dst.write(result, 1)

        # Loading final output to QGIS GUI viewer
        layer = QgsRasterLayer(rasOutput, f"{rasOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

        # QMessageBox.information(self.dlg, "Message", f"Rasterized file has been created /n CRS EPSG:{UTM_crs} /nthreshold Distance {bufferDistance}m")


    def IDW(self):

        workingDir = self.dlg.workingDir_Field.text()
        tempDir = workingDir + "temp"
        os.mkdir(tempDir)

        #INPUT
        countryAdminLayer = self.dlg.countryLayer_Field.filePath()
        UTM_crs = self.dlg.CRS_comboBox.currentText().split(":")[1].strip()
        FaciltyPointlayer = self.dlg.pointLayer_Field.filePath()
        bufferDistance = self.dlg.bufferDistance_spinBox.value()
        pixelSize = self.dlg.pixelSize_spinBox.value()

        # OUTPUT
        countryAdminLayer_utm_otput = f"{tempDir}/Admin0_UTM.shp"
        FaciltyPoint_utm_output = f"{tempDir}/university_UTM.shp"
        lineToPoint_output = f"{tempDir}/lineToPoint.shp"
        mergedPoints_output = f"{tempDir}/mergedPoints.shp"
        finalOutput = self.dlg.IDWRasterOutputFilePath_Field.text()

        # Convert spatial data to UTM CRS
        self.convertCRS(countryAdminLayer, UTM_crs)
        shp_utm.to_file(countryAdminLayer_utm_otput)

        self.convertCRS(FaciltyPointlayer, UTM_crs)
        shp_utm["EScore"] = 5
        shp_utm.to_file(FaciltyPoint_utm_output)

        #Geoprocessing Algorithms
        buffer = processing.run("native:buffer", {'INPUT': FaciltyPoint_utm_output,
                                                  'DISTANCE': bufferDistance,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'OUTPUT': "memory:"})
        bufferOutput = buffer["OUTPUT"]

        polyToLine = processing.run("native:polygonstolines", {'INPUT':bufferOutput,
                                                               'OUTPUT': "memory:"})

        polyToLineOutput = polyToLine["OUTPUT"]

        lineToPoint =  processing.run("native:pointsalonglines", {'INPUT':polyToLineOutput,
                                                                  'DISTANCE':1000,
                                                                  'START_OFFSET':0,
                                                                  'END_OFFSET':0,
                                                                  'OUTPUT': lineToPoint_output})


        lineToPoint_shp = gpd.read_file(lineToPoint_output)
        lineToPoint_shp["EScore"] = 0

        merged_gdf = pd.concat([shp_utm, lineToPoint_shp], ignore_index=True)
        merged_gdf.to_file(mergedPoints_output)

        layer = QgsVectorLayer(mergedPoints_output, "mergedPoints", 'ogr')
        desired_field = 'EScore'
        field_index = layer.fields().indexFromName(desired_field)

        IDW = processing.run("qgis:idwinterpolation", {'INTERPOLATION_DATA': mergedPoints_output + f"::~::0::~::{field_index}::~::0",     #'C:/Users/Andre/Nextcloud/GIS_WBGIT/QGIS_WBGIT/test.shp::~::0::~::3::~::0'
                                                       'DISTANCE_COEFFICIENT': 2,
                                                       'EXTENT': '306969.217500000,450078.884900000,8626350.630799999,8743170.112700000 [EPSG:32738]',
                                                       'PIXEL_SIZE': pixelSize,
                                                       'OUTPUT': finalOutput})


        layer = QgsRasterLayer(finalOutput, f"{finalOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

        QMessageBox.information(self.dlg, "Message", f"IDW interpolated raster file has been created /n CRS EPSG:{UTM_crs} /threshold Distance {bufferDistance}m")

    def ServiceArea(self):

        workingDir = self.dlg.workingDir_Field.text()
        tempDir = workingDir + "temp"
        os.mkdir(tempDir)

        # INPUT
        FaciltyPointlayer = self.dlg.pointLayer_Field_2.filePath()

        # Setting Travel Mode
        if self.dlg.travelMode_comboBox.currentText() == "Driving-car":
            traveMode = 0
        elif self.dlg.travelMode_comboBox.currentText() == "Walking":
            traveMode = 6
        else:
            pass

        # Setting Measurment Metric
        if self.dlg.metric_comboBox.currentText() == "Driving-car":
            metric = 0
        elif self.dlg.metric_comboBox.currentText() == "Walking":
            metric = 1
        else:
            pass

        ranges = self.dlg.serviceAreaRanges_Field.text()
        
        pixelSize = self.dlg.pixelSize_spinBox_3.value()

        # OUTPUT
        countryAdminLayer_utm_otput = f"{tempDir}/Admin0_UTM.shp"
        SAOutput = f"{tempDir}/SA_OUTPUT.shp"
        finalOutput = self.dlg.serviceAreaOutputFilePath_Field.text()

        
        Service_Area = processing.run("ORS Tools:isochrones_from_layer", {'INPUT_PROVIDER': 0,
                                                                          'INPUT_PROFILE': traveMode,
                                                                          'INPUT_POINT_LAYER': FaciltyPointlayer,
                                                                          'INPUT_FIELD': '',
                                                                          'INPUT_METRIC': 0,
                                                                          'INPUT_RANGES': ranges,
                                                                          'INPUT_AVOID_FEATURES': [],
                                                                          'INPUT_AVOID_BORDERS': None,
                                                                          'INPUT_AVOID_COUNTRIES': '',
                                                                          'INPUT_AVOID_POLYGONS': None,
                                                                          'OUTPUT': SAOutput})

        SA_df = gpd.read_file(SAOutput)
        no_spaces_string = "".join(ranges.split())
        ranges_list = no_spaces_string.split(",")
        int_ranges_list = [int(x) for x in ranges_list]
        int_ranges_list.sort()

        # QMessageBox.information(self.dlg, "Message", f"{ranges_list}")
        for i in int_ranges_list:
            df = SA_df[SA_df['AA_MINS'] == i]
            output = f"{tempDir}/band_{i}"
            df.to_file(output + ".shp")

            dissolve = processing.run("native:dissolve", {'INPUT': output + ".shp",
                                                          'FIELD':[],
                                                          'SEPARATE_DISJOINT':False,
                                                          'OUTPUT':f"{output}_dis.shp"})
        Merge_list = []
        len_range = len(int_ranges_list)
        int_ranges_list.sort(reverse=True)
        for i in range(0, len_range-1):
            output = f"{tempDir}/band_dif_{int_ranges_list[i]}_-_{int_ranges_list[i+1]}.shp"
            Merge_list.append(output)
            processing.run("native:difference", {'INPUT': f"{tempDir}/band_{int_ranges_list[i]}_dis.shp",
                                                 'OVERLAY': f"{tempDir}/band_{int_ranges_list[i+1]}_dis.shp",
                                                 'OUTPUT': output,
                                                 'GRID_SIZE': None})

        Merge_list.append(f"{tempDir}/band_{int_ranges_list[-1]}_dis.shp")

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': Merge_list,
                                                            'CRS':None,
                                                            'OUTPUT':finalOutput})

        
        # Loading final output to QGIS GUI viewer
        layer = QgsVectorLayer(finalOutput, f"{finalOutput}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

    def MCA(self):
        # workingDir = self.dlg.workingDir_Field.text()

        #INPUT
        Factor1_ras = self.dlg.factor1_Field.filePath()
        Factor2_ras = self.dlg.factor2_Field.filePath()


        #OUTPUT
        MCA_output = self.dlg.MCAOutputFilePath_Field.text()


        with rasterio.open(Factor1_ras) as src:
            ras1 = src.read(1)
            meta1 = src.meta

        with rasterio.open(Factor2_ras) as src:
            ras2 = src.read(1)

        # Raster Calculation
        Factor1_weight = self.dlg.IDWweight_spinBox.value() / 100
        Factor2_weight = self.dlg.rasterizeWeight_spinBox.value() / 100
        result = ((Factor1_weight*ras1) + (Factor2_weight*ras2))


        meta1.update(dtype=rasterio.float32)

        with rasterio.open(MCA_output, 'w', **meta1) as dst:
            dst.write(result, 1)

        layer = QgsRasterLayer(MCA_output, f"{MCA_output}")

        if not layer.isValid():
            print("Layer failed to load!")

        QgsProject.instance().addMapLayer(layer)

        QMessageBox.information(self.dlg, "Message", f"{type(result)}")
